# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import sys
from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
from urllib.parse import parse_qs, urljoin, urlparse

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    map_error,
)
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpResponse
from azure.core.polling import LROPoller, NoPolling, PollingMethod
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict
from azure.mgmt.core.exceptions import ARMErrorFormat
from azure.mgmt.core.polling.arm_polling import ARMPolling

from .._serialization import Serializer
from .._vendor import _format_url_section

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_exports_list_request(scope: str, *, expand: Optional[str] = None, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2021-10-01"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.CostManagement/exports"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if expand is not None:
        _params["$expand"] = _SERIALIZER.query("expand", expand, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_exports_get_request(
    scope: str, export_name: str, *, expand: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2021-10-01"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.CostManagement/exports/{exportName}"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
        "exportName": _SERIALIZER.url("export_name", export_name, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if expand is not None:
        _params["$expand"] = _SERIALIZER.query("expand", expand, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_exports_create_or_update_request(scope: str, export_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2021-10-01"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.CostManagement/exports/{exportName}"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
        "exportName": _SERIALIZER.url("export_name", export_name, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_exports_delete_request(scope: str, export_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2021-10-01"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.CostManagement/exports/{exportName}"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
        "exportName": _SERIALIZER.url("export_name", export_name, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_exports_execute_request(scope: str, export_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2021-10-01"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.CostManagement/exports/{exportName}/run"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
        "exportName": _SERIALIZER.url("export_name", export_name, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_exports_get_execution_history_request(scope: str, export_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2021-10-01"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.CostManagement/exports/{exportName}/runHistory"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
        "exportName": _SERIALIZER.url("export_name", export_name, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_generate_detailed_cost_report_create_operation_request(scope: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2021-10-01"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.CostManagement/generateDetailedCostReport"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_generate_detailed_cost_report_operation_results_get_request(
    operation_id: str, scope: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2021-10-01"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.CostManagement/operationResults/{operationId}"
    path_format_arguments = {
        "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_generate_detailed_cost_report_operation_status_get_request(
    operation_id: str, scope: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2021-10-01"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.CostManagement/operationStatus/{operationId}"
    path_format_arguments = {
        "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_views_list_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2021-10-01"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.CostManagement/views"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_views_list_by_scope_request(scope: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2021-10-01"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.CostManagement/views"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_views_get_request(view_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2021-10-01"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.CostManagement/views/{viewName}"
    path_format_arguments = {
        "viewName": _SERIALIZER.url("view_name", view_name, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_views_create_or_update_request(view_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2021-10-01"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.CostManagement/views/{viewName}"
    path_format_arguments = {
        "viewName": _SERIALIZER.url("view_name", view_name, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_views_delete_request(view_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2021-10-01"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.CostManagement/views/{viewName}"
    path_format_arguments = {
        "viewName": _SERIALIZER.url("view_name", view_name, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_views_get_by_scope_request(scope: str, view_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2021-10-01"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.CostManagement/views/{viewName}"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str"),
        "viewName": _SERIALIZER.url("view_name", view_name, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_views_create_or_update_by_scope_request(scope: str, view_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2021-10-01"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.CostManagement/views/{viewName}"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str"),
        "viewName": _SERIALIZER.url("view_name", view_name, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_views_delete_by_scope_request(scope: str, view_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2021-10-01"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.CostManagement/views/{viewName}"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str"),
        "viewName": _SERIALIZER.url("view_name", view_name, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_alerts_list_request(scope: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2021-10-01"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.CostManagement/alerts"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_alerts_get_request(scope: str, alert_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2021-10-01"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.CostManagement/alerts/{alertId}"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
        "alertId": _SERIALIZER.url("alert_id", alert_id, "str", skip_quote=True),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_alerts_dismiss_request(scope: str, alert_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2021-10-01"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.CostManagement/alerts/{alertId}"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
        "alertId": _SERIALIZER.url("alert_id", alert_id, "str", skip_quote=True),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_alerts_list_external_request(
    external_cloud_provider_type: str, external_cloud_provider_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2021-10-01"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.CostManagement/{externalCloudProviderType}/{externalCloudProviderId}/alerts"
    path_format_arguments = {
        "externalCloudProviderType": _SERIALIZER.url(
            "external_cloud_provider_type", external_cloud_provider_type, "str"
        ),
        "externalCloudProviderId": _SERIALIZER.url("external_cloud_provider_id", external_cloud_provider_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_forecast_usage_request(scope: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    filter = kwargs.pop("filter", _params.pop("$filter", None))  # type: Optional[str]
    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2021-10-01"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.CostManagement/forecast"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if filter is not None:
        _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_forecast_external_cloud_provider_usage_request(
    external_cloud_provider_type: str, external_cloud_provider_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    filter = kwargs.pop("filter", _params.pop("$filter", None))  # type: Optional[str]
    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2021-10-01"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.CostManagement/{externalCloudProviderType}/{externalCloudProviderId}/forecast"
    path_format_arguments = {
        "externalCloudProviderType": _SERIALIZER.url(
            "external_cloud_provider_type", external_cloud_provider_type, "str"
        ),
        "externalCloudProviderId": _SERIALIZER.url("external_cloud_provider_id", external_cloud_provider_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if filter is not None:
        _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_dimensions_list_request(
    scope: str,
    *,
    filter: Optional[str] = None,
    expand: Optional[str] = None,
    skiptoken: Optional[str] = None,
    top: Optional[int] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2021-10-01"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.CostManagement/dimensions"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if filter is not None:
        _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
    if expand is not None:
        _params["$expand"] = _SERIALIZER.query("expand", expand, "str")
    if skiptoken is not None:
        _params["$skiptoken"] = _SERIALIZER.query("skiptoken", skiptoken, "str")
    if top is not None:
        _params["$top"] = _SERIALIZER.query("top", top, "int", maximum=1000, minimum=1)

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_dimensions_by_external_cloud_provider_type_request(
    external_cloud_provider_type: str,
    external_cloud_provider_id: str,
    *,
    filter: Optional[str] = None,
    expand: Optional[str] = None,
    skiptoken: Optional[str] = None,
    top: Optional[int] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2021-10-01"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.CostManagement/{externalCloudProviderType}/{externalCloudProviderId}/dimensions"
    path_format_arguments = {
        "externalCloudProviderType": _SERIALIZER.url(
            "external_cloud_provider_type", external_cloud_provider_type, "str"
        ),
        "externalCloudProviderId": _SERIALIZER.url("external_cloud_provider_id", external_cloud_provider_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if filter is not None:
        _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
    if expand is not None:
        _params["$expand"] = _SERIALIZER.query("expand", expand, "str")
    if skiptoken is not None:
        _params["$skiptoken"] = _SERIALIZER.query("skiptoken", skiptoken, "str")
    if top is not None:
        _params["$top"] = _SERIALIZER.query("top", top, "int", maximum=1000, minimum=1)

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_query_usage_request(scope: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2021-10-01"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/{scope}/providers/Microsoft.CostManagement/query"
    path_format_arguments = {
        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_query_usage_by_external_cloud_provider_type_request(
    external_cloud_provider_type: str, external_cloud_provider_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2021-10-01"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.CostManagement/{externalCloudProviderType}/{externalCloudProviderId}/query"
    path_format_arguments = {
        "externalCloudProviderType": _SERIALIZER.url(
            "external_cloud_provider_type", external_cloud_provider_type, "str"
        ),
        "externalCloudProviderId": _SERIALIZER.url("external_cloud_provider_id", external_cloud_provider_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_generate_reservation_details_report_by_billing_account_id_request(
    billing_account_id: str, *, start_date: str, end_date: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2021-10-01"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/providers/Microsoft.CostManagement/generateReservationDetailsReport"  # pylint: disable=line-too-long
    path_format_arguments = {
        "billingAccountId": _SERIALIZER.url("billing_account_id", billing_account_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["startDate"] = _SERIALIZER.query("start_date", start_date, "str")
    _params["endDate"] = _SERIALIZER.query("end_date", end_date, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_generate_reservation_details_report_by_billing_profile_id_request(
    billing_account_id: str, billing_profile_id: str, *, start_date: str, end_date: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2021-10-01"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/providers/Microsoft.CostManagement/generateReservationDetailsReport"  # pylint: disable=line-too-long
    path_format_arguments = {
        "billingAccountId": _SERIALIZER.url("billing_account_id", billing_account_id, "str"),
        "billingProfileId": _SERIALIZER.url("billing_profile_id", billing_profile_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["startDate"] = _SERIALIZER.query("start_date", start_date, "str")
    _params["endDate"] = _SERIALIZER.query("end_date", end_date, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_operations_list_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2021-10-01"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/providers/Microsoft.CostManagement/operations"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


class ExportsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.costmanagement.CostManagementClient`'s
        :attr:`exports` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, scope: str, *, expand: Optional[str] = None, **kwargs: Any) -> JSON:
        """The operation to list all exports at the given scope.

        :param scope: The scope associated with export operations. This includes
         '/subscriptions/{subscriptionId}/' for subscription scope,
         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
         for Department scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
         for EnrollmentAccount scope,
         '/providers/Microsoft.Management/managementGroups/{managementGroupId} for Management Group
         scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
         for billingProfile scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
         for invoiceSection scope, and
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}'
         specific for partners. Required.
        :type scope: str
        :keyword expand: May be used to expand the properties within an export. Currently only
         'runHistory' is supported and will return information for the last execution of each export.
         Default value is None.
        :paramtype expand: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "eTag": "str",  # Optional. eTag of the resource. To handle
                              concurrent update scenario, this field will be used to determine whether
                              the user is updating the latest version or not.
                            "id": "str",  # Optional. Resource Id.
                            "name": "str",  # Optional. Resource name.
                            "properties": {
                                "definition": {
                                    "dataSet": {
                                        "configuration": {
                                            "columns": [
                                                "str"  # Optional.
                                                  Array of column names to be included in the export.
                                                  If not provided then the export will include all
                                                  available columns. The available columns can vary by
                                                  customer channel (see examples).
                                            ]
                                        },
                                        "granularity": "str"  # Optional. The
                                          granularity of rows in the export. Currently only 'Daily' is
                                          supported. "Daily"
                                    },
                                    "timePeriod": {
                                        "from": "2020-02-20 00:00:00",  # The
                                          start date for export data. Required.
                                        "to": "2020-02-20 00:00:00"  # The
                                          end date for export data. Required.
                                    },
                                    "timeframe": "str",  # The time frame for
                                      pulling data for the export. If custom, then a specific time
                                      period must be provided. Required. Known values are:
                                      "MonthToDate", "BillingMonthToDate", "TheLastMonth",
                                      "TheLastBillingMonth", "WeekToDate", and "Custom".
                                    "type": "str"  # The type of the export. Note
                                      that 'Usage' is equivalent to 'ActualCost' and is applicable to
                                      exports that do not yet provide data for charges or amortization
                                      for service reservations. Required. Known values are: "Usage",
                                      "ActualCost", and "AmortizedCost".
                                },
                                "deliveryInfo": {
                                    "destination": {
                                        "container": "str",  # The name of
                                          the container where exports will be uploaded. If the
                                          container does not exist it will be created. Required.
                                        "resourceId": "str",  # Optional. The
                                          resource id of the storage account where exports will be
                                          delivered. This is not required if a sasToken and
                                          storageAccount are specified.
                                        "rootFolderPath": "str",  # Optional.
                                          The name of the directory where exports will be uploaded.
                                        "sasToken": "str",  # Optional. A SAS
                                          token for the storage account. For a restricted set of Azure
                                          customers this together with storageAccount can be specified
                                          instead of resourceId. Note: the value returned by the API
                                          for this property will always be obfuscated. Returning this
                                          same obfuscated value will not result in the SAS token being
                                          updated. To update this value a new SAS token must be
                                          specified.
                                        "storageAccount": "str"  # Optional.
                                          The storage account where exports will be uploaded. For a
                                          restricted set of Azure customers this together with sasToken
                                          can be specified instead of resourceId.
                                    }
                                },
                                "format": "str",  # Optional. The format of the
                                  export being delivered. Currently only 'Csv' is supported. "Csv"
                                "nextRunTimeEstimate": "2020-02-20 00:00:00",  #
                                  Optional. If the export has an active schedule, provides an estimate
                                  of the next execution time.
                                "partitionData": bool,  # Optional. If set to true,
                                  exported data will be partitioned by size and placed in a blob
                                  directory together with a manifest file. Note: this option is
                                  currently available only for modern commerce scopes.
                                "runHistory": {
                                    "value": [
                                        {
                                            "eTag": "str",  # Optional.
                                              eTag of the resource. To handle concurrent update
                                              scenario, this field will be used to determine whether
                                              the user is updating the latest version or not.
                                            "id": "str",  # Optional.
                                              Resource Id.
                                            "name": "str",  # Optional.
                                              Resource name.
                                            "properties": {
                                                "error": {
                                                    "code":
                                                      "str",  # Optional. Error code.
                                                    "message":
                                                      "str"  # Optional. Error message indicating why
                                                      the operation failed.
                                                },
                                                "executionType":
                                                  "str",  # Optional. The type of the export execution.
                                                  Known values are: "OnDemand" and "Scheduled".
                                                "fileName": "str",  #
                                                  Optional. The name of the exported file.
                                                "processingEndTime":
                                                  "2020-02-20 00:00:00",  # Optional. The time when the
                                                  export execution finished.
                "processingStartTime": "2020-02-20 00:00:00",  #
                                                  Optional. The time when export was picked up to be
                                                  executed.
                                                "runSettings": {
                                                    "definition":
                                                      {
                "dataSet": {
                "configuration": {
                "columns": [
                "str"  # Optional. Array of
                                                                      column names to be included in
                                                                      the export. If not provided then
                                                                      the export will include all
                                                                      available columns. The available
                                                                      columns can vary by customer
                                                                      channel (see examples).
                ]
                },
                "granularity": "str"  # Optional. The
                                                              granularity of rows in the export.
                                                              Currently only 'Daily' is supported.
                                                              "Daily"
                                                        },
                "timePeriod": {
                "from": "2020-02-20 00:00:00",  # The
                                                              start date for export data. Required.
                "to": "2020-02-20 00:00:00"  # The end
                                                              date for export data. Required.
                                                        },
                "timeframe": "str",  # The time frame for
                                                          pulling data for the export. If custom, then
                                                          a specific time period must be provided.
                                                          Required. Known values are: "MonthToDate",
                                                          "BillingMonthToDate", "TheLastMonth",
                                                          "TheLastBillingMonth", "WeekToDate", and
                                                          "Custom".
                "type": "str"  # The type of the export. Note
                                                          that 'Usage' is equivalent to 'ActualCost'
                                                          and is applicable to exports that do not yet
                                                          provide data for charges or amortization for
                                                          service reservations. Required. Known values
                                                          are: "Usage", "ActualCost", and
                                                          "AmortizedCost".
                                                    },
                "deliveryInfo": {
                "destination": {
                "container": "str",  # The name of the
                                                              container where exports will be uploaded.
                                                              If the container does not exist it will
                                                              be created. Required.
                "resourceId": "str",  # Optional. The
                                                              resource id of the storage account where
                                                              exports will be delivered. This is not
                                                              required if a sasToken and storageAccount
                                                              are specified.
                "rootFolderPath": "str",  # Optional. The
                                                              name of the directory where exports will
                                                              be uploaded.
                "sasToken": "str",  # Optional. A SAS
                                                              token for the storage account. For a
                                                              restricted set of Azure customers this
                                                              together with storageAccount can be
                                                              specified instead of resourceId. Note:
                                                              the value returned by the API for this
                                                              property will always be obfuscated.
                                                              Returning this same obfuscated value will
                                                              not result in the SAS token being
                                                              updated. To update this value a new SAS
                                                              token must be specified.
                "storageAccount": "str"  # Optional. The
                                                              storage account where exports will be
                                                              uploaded. For a restricted set of Azure
                                                              customers this together with sasToken can
                                                              be specified instead of resourceId.
                                                        }
                                                    },
                                                    "format":
                                                      "str",  # Optional. The format of the export
                                                      being delivered. Currently only 'Csv' is
                                                      supported. "Csv"
                "nextRunTimeEstimate": "2020-02-20 00:00:00",  #
                                                      Optional. If the export has an active schedule,
                                                      provides an estimate of the next execution time.
                "partitionData": bool,  # Optional. If set to
                                                      true, exported data will be partitioned by size
                                                      and placed in a blob directory together with a
                                                      manifest file. Note: this option is currently
                                                      available only for modern commerce scopes.
                                                    "runHistory":
                                                      ...
                                                },
                                                "status": "str",  #
                                                  Optional. The last known status of the export
                                                  execution. Known values are: "Queued", "InProgress",
                                                  "Completed", "Failed", "Timeout",
                                                  "NewDataNotAvailable", and "DataNotAvailable".
                                                "submittedBy": "str",
                                                  # Optional. The identifier for the entity that
                                                  executed the export. For OnDemand executions it is
                                                  the user email. For scheduled executions it is
                                                  'System'.
                                                "submittedTime":
                                                  "2020-02-20 00:00:00"  # Optional. The time when
                                                  export was queued to be executed.
                                            },
                                            "type": "str"  # Optional.
                                              Resource type.
                                        }
                                    ]
                                },
                                "schedule": {
                                    "recurrence": "str",  # Optional. The
                                      schedule recurrence. Known values are: "Daily", "Weekly",
                                      "Monthly", and "Annually".
                                    "recurrencePeriod": {
                                        "from": "2020-02-20 00:00:00",  # The
                                          start date of recurrence. Required.
                                        "to": "2020-02-20 00:00:00"  #
                                          Optional. The end date of recurrence.
                                    },
                                    "status": "str"  # Optional. The status of
                                      the export's schedule. If 'Inactive', the export's schedule is
                                      paused. Known values are: "Active" and "Inactive".
                                }
                            },
                            "type": "str"  # Optional. Resource type.
                        }
                    ]
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_exports_list_request(
            scope=scope,
            expand=expand,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def get(self, scope: str, export_name: str, *, expand: Optional[str] = None, **kwargs: Any) -> JSON:
        """The operation to get the export for the defined scope by export name.

        :param scope: The scope associated with export operations. This includes
         '/subscriptions/{subscriptionId}/' for subscription scope,
         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
         for Department scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
         for EnrollmentAccount scope,
         '/providers/Microsoft.Management/managementGroups/{managementGroupId} for Management Group
         scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
         for billingProfile scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
         for invoiceSection scope, and
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}'
         specific for partners. Required.
        :type scope: str
        :param export_name: Export Name. Required.
        :type export_name: str
        :keyword expand: May be used to expand the properties within an export. Currently only
         'runHistory' is supported and will return information for the last 10 executions of the export.
         Default value is None.
        :paramtype expand: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "eTag": "str",  # Optional. eTag of the resource. To handle concurrent update
                      scenario, this field will be used to determine whether the user is updating the
                      latest version or not.
                    "id": "str",  # Optional. Resource Id.
                    "name": "str",  # Optional. Resource name.
                    "properties": {
                        "definition": {
                            "dataSet": {
                                "configuration": {
                                    "columns": [
                                        "str"  # Optional. Array of column
                                          names to be included in the export. If not provided then the
                                          export will include all available columns. The available
                                          columns can vary by customer channel (see examples).
                                    ]
                                },
                                "granularity": "str"  # Optional. The granularity of
                                  rows in the export. Currently only 'Daily' is supported. "Daily"
                            },
                            "timePeriod": {
                                "from": "2020-02-20 00:00:00",  # The start date for
                                  export data. Required.
                                "to": "2020-02-20 00:00:00"  # The end date for
                                  export data. Required.
                            },
                            "timeframe": "str",  # The time frame for pulling data for
                              the export. If custom, then a specific time period must be provided.
                              Required. Known values are: "MonthToDate", "BillingMonthToDate",
                              "TheLastMonth", "TheLastBillingMonth", "WeekToDate", and "Custom".
                            "type": "str"  # The type of the export. Note that 'Usage' is
                              equivalent to 'ActualCost' and is applicable to exports that do not yet
                              provide data for charges or amortization for service reservations.
                              Required. Known values are: "Usage", "ActualCost", and "AmortizedCost".
                        },
                        "deliveryInfo": {
                            "destination": {
                                "container": "str",  # The name of the container
                                  where exports will be uploaded. If the container does not exist it
                                  will be created. Required.
                                "resourceId": "str",  # Optional. The resource id of
                                  the storage account where exports will be delivered. This is not
                                  required if a sasToken and storageAccount are specified.
                                "rootFolderPath": "str",  # Optional. The name of the
                                  directory where exports will be uploaded.
                                "sasToken": "str",  # Optional. A SAS token for the
                                  storage account. For a restricted set of Azure customers this
                                  together with storageAccount can be specified instead of resourceId.
                                  Note: the value returned by the API for this property will always be
                                  obfuscated. Returning this same obfuscated value will not result in
                                  the SAS token being updated. To update this value a new SAS token
                                  must be specified.
                                "storageAccount": "str"  # Optional. The storage
                                  account where exports will be uploaded. For a restricted set of Azure
                                  customers this together with sasToken can be specified instead of
                                  resourceId.
                            }
                        },
                        "format": "str",  # Optional. The format of the export being
                          delivered. Currently only 'Csv' is supported. "Csv"
                        "nextRunTimeEstimate": "2020-02-20 00:00:00",  # Optional. If the
                          export has an active schedule, provides an estimate of the next execution
                          time.
                        "partitionData": bool,  # Optional. If set to true, exported data
                          will be partitioned by size and placed in a blob directory together with a
                          manifest file. Note: this option is currently available only for modern
                          commerce scopes.
                        "runHistory": {
                            "value": [
                                {
                                    "eTag": "str",  # Optional. eTag of the
                                      resource. To handle concurrent update scenario, this field will
                                      be used to determine whether the user is updating the latest
                                      version or not.
                                    "id": "str",  # Optional. Resource Id.
                                    "name": "str",  # Optional. Resource name.
                                    "properties": {
                                        "error": {
                                            "code": "str",  # Optional.
                                              Error code.
                                            "message": "str"  # Optional.
                                              Error message indicating why the operation failed.
                                        },
                                        "executionType": "str",  # Optional.
                                          The type of the export execution. Known values are:
                                          "OnDemand" and "Scheduled".
                                        "fileName": "str",  # Optional. The
                                          name of the exported file.
                                        "processingEndTime": "2020-02-20
                                          00:00:00",  # Optional. The time when the export execution
                                          finished.
                                        "processingStartTime": "2020-02-20
                                          00:00:00",  # Optional. The time when export was picked up to
                                          be executed.
                                        "runSettings": {
                                            "definition": {
                                                "dataSet": {
                "configuration": {
                "columns": [
                "str"  # Optional. Array of column names
                                                              to be included in the export. If not
                                                              provided then the export will include all
                                                              available columns. The available columns
                                                              can vary by customer channel (see
                                                              examples).
                                                        ]
                                                    },
                "granularity": "str"  # Optional. The granularity
                                                      of rows in the export. Currently only 'Daily' is
                                                      supported. "Daily"
                                                },
                                                "timePeriod": {
                                                    "from":
                                                      "2020-02-20 00:00:00",  # The start date for
                                                      export data. Required.
                                                    "to":
                                                      "2020-02-20 00:00:00"  # The end date for export
                                                      data. Required.
                                                },
                                                "timeframe": "str",
                                                  # The time frame for pulling data for the export. If
                                                  custom, then a specific time period must be provided.
                                                  Required. Known values are: "MonthToDate",
                                                  "BillingMonthToDate", "TheLastMonth",
                                                  "TheLastBillingMonth", "WeekToDate", and "Custom".
                                                "type": "str"  # The
                                                  type of the export. Note that 'Usage' is equivalent
                                                  to 'ActualCost' and is applicable to exports that do
                                                  not yet provide data for charges or amortization for
                                                  service reservations. Required. Known values are:
                                                  "Usage", "ActualCost", and "AmortizedCost".
                                            },
                                            "deliveryInfo": {
                                                "destination": {
                                                    "container":
                                                      "str",  # The name of the container where exports
                                                      will be uploaded. If the container does not exist
                                                      it will be created. Required.
                                                    "resourceId":
                                                      "str",  # Optional. The resource id of the
                                                      storage account where exports will be delivered.
                                                      This is not required if a sasToken and
                                                      storageAccount are specified.
                "rootFolderPath": "str",  # Optional. The name of
                                                      the directory where exports will be uploaded.
                                                    "sasToken":
                                                      "str",  # Optional. A SAS token for the storage
                                                      account. For a restricted set of Azure customers
                                                      this together with storageAccount can be
                                                      specified instead of resourceId. Note: the value
                                                      returned by the API for this property will always
                                                      be obfuscated. Returning this same obfuscated
                                                      value will not result in the SAS token being
                                                      updated. To update this value a new SAS token
                                                      must be specified.
                "storageAccount": "str"  # Optional. The storage
                                                      account where exports will be uploaded. For a
                                                      restricted set of Azure customers this together
                                                      with sasToken can be specified instead of
                                                      resourceId.
                                                }
                                            },
                                            "format": "str",  # Optional.
                                              The format of the export being delivered. Currently only
                                              'Csv' is supported. "Csv"
                                            "nextRunTimeEstimate":
                                              "2020-02-20 00:00:00",  # Optional. If the export has an
                                              active schedule, provides an estimate of the next
                                              execution time.
                                            "partitionData": bool,  #
                                              Optional. If set to true, exported data will be
                                              partitioned by size and placed in a blob directory
                                              together with a manifest file. Note: this option is
                                              currently available only for modern commerce scopes.
                                            "runHistory": ...
                                        },
                                        "status": "str",  # Optional. The
                                          last known status of the export execution. Known values are:
                                          "Queued", "InProgress", "Completed", "Failed", "Timeout",
                                          "NewDataNotAvailable", and "DataNotAvailable".
                                        "submittedBy": "str",  # Optional.
                                          The identifier for the entity that executed the export. For
                                          OnDemand executions it is the user email. For scheduled
                                          executions it is 'System'.
                                        "submittedTime": "2020-02-20
                                          00:00:00"  # Optional. The time when export was queued to be
                                          executed.
                                    },
                                    "type": "str"  # Optional. Resource type.
                                }
                            ]
                        },
                        "schedule": {
                            "recurrence": "str",  # Optional. The schedule recurrence.
                              Known values are: "Daily", "Weekly", "Monthly", and "Annually".
                            "recurrencePeriod": {
                                "from": "2020-02-20 00:00:00",  # The start date of
                                  recurrence. Required.
                                "to": "2020-02-20 00:00:00"  # Optional. The end date
                                  of recurrence.
                            },
                            "status": "str"  # Optional. The status of the export's
                              schedule. If 'Inactive', the export's schedule is paused. Known values
                              are: "Active" and "Inactive".
                        }
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_exports_get_request(
            scope=scope,
            export_name=export_name,
            expand=expand,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def create_or_update(
        self, scope: str, export_name: str, parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """The operation to create or update a export. Update operation requires latest eTag to be set in
        the request. You may obtain the latest eTag by performing a get operation. Create operation
        does not require eTag.

        :param scope: The scope associated with export operations. This includes
         '/subscriptions/{subscriptionId}/' for subscription scope,
         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
         for Department scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
         for EnrollmentAccount scope,
         '/providers/Microsoft.Management/managementGroups/{managementGroupId} for Management Group
         scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
         for billingProfile scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
         for invoiceSection scope, and
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}'
         specific for partners. Required.
        :type scope: str
        :param export_name: Export Name. Required.
        :type export_name: str
        :param parameters: Parameters supplied to the CreateOrUpdate Export operation. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "eTag": "str",  # Optional. eTag of the resource. To handle concurrent update
                      scenario, this field will be used to determine whether the user is updating the
                      latest version or not.
                    "id": "str",  # Optional. Resource Id.
                    "name": "str",  # Optional. Resource name.
                    "properties": {
                        "definition": {
                            "dataSet": {
                                "configuration": {
                                    "columns": [
                                        "str"  # Optional. Array of column
                                          names to be included in the export. If not provided then the
                                          export will include all available columns. The available
                                          columns can vary by customer channel (see examples).
                                    ]
                                },
                                "granularity": "str"  # Optional. The granularity of
                                  rows in the export. Currently only 'Daily' is supported. "Daily"
                            },
                            "timePeriod": {
                                "from": "2020-02-20 00:00:00",  # The start date for
                                  export data. Required.
                                "to": "2020-02-20 00:00:00"  # The end date for
                                  export data. Required.
                            },
                            "timeframe": "str",  # The time frame for pulling data for
                              the export. If custom, then a specific time period must be provided.
                              Required. Known values are: "MonthToDate", "BillingMonthToDate",
                              "TheLastMonth", "TheLastBillingMonth", "WeekToDate", and "Custom".
                            "type": "str"  # The type of the export. Note that 'Usage' is
                              equivalent to 'ActualCost' and is applicable to exports that do not yet
                              provide data for charges or amortization for service reservations.
                              Required. Known values are: "Usage", "ActualCost", and "AmortizedCost".
                        },
                        "deliveryInfo": {
                            "destination": {
                                "container": "str",  # The name of the container
                                  where exports will be uploaded. If the container does not exist it
                                  will be created. Required.
                                "resourceId": "str",  # Optional. The resource id of
                                  the storage account where exports will be delivered. This is not
                                  required if a sasToken and storageAccount are specified.
                                "rootFolderPath": "str",  # Optional. The name of the
                                  directory where exports will be uploaded.
                                "sasToken": "str",  # Optional. A SAS token for the
                                  storage account. For a restricted set of Azure customers this
                                  together with storageAccount can be specified instead of resourceId.
                                  Note: the value returned by the API for this property will always be
                                  obfuscated. Returning this same obfuscated value will not result in
                                  the SAS token being updated. To update this value a new SAS token
                                  must be specified.
                                "storageAccount": "str"  # Optional. The storage
                                  account where exports will be uploaded. For a restricted set of Azure
                                  customers this together with sasToken can be specified instead of
                                  resourceId.
                            }
                        },
                        "format": "str",  # Optional. The format of the export being
                          delivered. Currently only 'Csv' is supported. "Csv"
                        "nextRunTimeEstimate": "2020-02-20 00:00:00",  # Optional. If the
                          export has an active schedule, provides an estimate of the next execution
                          time.
                        "partitionData": bool,  # Optional. If set to true, exported data
                          will be partitioned by size and placed in a blob directory together with a
                          manifest file. Note: this option is currently available only for modern
                          commerce scopes.
                        "runHistory": {
                            "value": [
                                {
                                    "eTag": "str",  # Optional. eTag of the
                                      resource. To handle concurrent update scenario, this field will
                                      be used to determine whether the user is updating the latest
                                      version or not.
                                    "id": "str",  # Optional. Resource Id.
                                    "name": "str",  # Optional. Resource name.
                                    "properties": {
                                        "error": {
                                            "code": "str",  # Optional.
                                              Error code.
                                            "message": "str"  # Optional.
                                              Error message indicating why the operation failed.
                                        },
                                        "executionType": "str",  # Optional.
                                          The type of the export execution. Known values are:
                                          "OnDemand" and "Scheduled".
                                        "fileName": "str",  # Optional. The
                                          name of the exported file.
                                        "processingEndTime": "2020-02-20
                                          00:00:00",  # Optional. The time when the export execution
                                          finished.
                                        "processingStartTime": "2020-02-20
                                          00:00:00",  # Optional. The time when export was picked up to
                                          be executed.
                                        "runSettings": {
                                            "definition": {
                                                "dataSet": {
                "configuration": {
                "columns": [
                "str"  # Optional. Array of column names
                                                              to be included in the export. If not
                                                              provided then the export will include all
                                                              available columns. The available columns
                                                              can vary by customer channel (see
                                                              examples).
                                                        ]
                                                    },
                "granularity": "str"  # Optional. The granularity
                                                      of rows in the export. Currently only 'Daily' is
                                                      supported. "Daily"
                                                },
                                                "timePeriod": {
                                                    "from":
                                                      "2020-02-20 00:00:00",  # The start date for
                                                      export data. Required.
                                                    "to":
                                                      "2020-02-20 00:00:00"  # The end date for export
                                                      data. Required.
                                                },
                                                "timeframe": "str",
                                                  # The time frame for pulling data for the export. If
                                                  custom, then a specific time period must be provided.
                                                  Required. Known values are: "MonthToDate",
                                                  "BillingMonthToDate", "TheLastMonth",
                                                  "TheLastBillingMonth", "WeekToDate", and "Custom".
                                                "type": "str"  # The
                                                  type of the export. Note that 'Usage' is equivalent
                                                  to 'ActualCost' and is applicable to exports that do
                                                  not yet provide data for charges or amortization for
                                                  service reservations. Required. Known values are:
                                                  "Usage", "ActualCost", and "AmortizedCost".
                                            },
                                            "deliveryInfo": {
                                                "destination": {
                                                    "container":
                                                      "str",  # The name of the container where exports
                                                      will be uploaded. If the container does not exist
                                                      it will be created. Required.
                                                    "resourceId":
                                                      "str",  # Optional. The resource id of the
                                                      storage account where exports will be delivered.
                                                      This is not required if a sasToken and
                                                      storageAccount are specified.
                "rootFolderPath": "str",  # Optional. The name of
                                                      the directory where exports will be uploaded.
                                                    "sasToken":
                                                      "str",  # Optional. A SAS token for the storage
                                                      account. For a restricted set of Azure customers
                                                      this together with storageAccount can be
                                                      specified instead of resourceId. Note: the value
                                                      returned by the API for this property will always
                                                      be obfuscated. Returning this same obfuscated
                                                      value will not result in the SAS token being
                                                      updated. To update this value a new SAS token
                                                      must be specified.
                "storageAccount": "str"  # Optional. The storage
                                                      account where exports will be uploaded. For a
                                                      restricted set of Azure customers this together
                                                      with sasToken can be specified instead of
                                                      resourceId.
                                                }
                                            },
                                            "format": "str",  # Optional.
                                              The format of the export being delivered. Currently only
                                              'Csv' is supported. "Csv"
                                            "nextRunTimeEstimate":
                                              "2020-02-20 00:00:00",  # Optional. If the export has an
                                              active schedule, provides an estimate of the next
                                              execution time.
                                            "partitionData": bool,  #
                                              Optional. If set to true, exported data will be
                                              partitioned by size and placed in a blob directory
                                              together with a manifest file. Note: this option is
                                              currently available only for modern commerce scopes.
                                            "runHistory": ...
                                        },
                                        "status": "str",  # Optional. The
                                          last known status of the export execution. Known values are:
                                          "Queued", "InProgress", "Completed", "Failed", "Timeout",
                                          "NewDataNotAvailable", and "DataNotAvailable".
                                        "submittedBy": "str",  # Optional.
                                          The identifier for the entity that executed the export. For
                                          OnDemand executions it is the user email. For scheduled
                                          executions it is 'System'.
                                        "submittedTime": "2020-02-20
                                          00:00:00"  # Optional. The time when export was queued to be
                                          executed.
                                    },
                                    "type": "str"  # Optional. Resource type.
                                }
                            ]
                        },
                        "schedule": {
                            "recurrence": "str",  # Optional. The schedule recurrence.
                              Known values are: "Daily", "Weekly", "Monthly", and "Annually".
                            "recurrencePeriod": {
                                "from": "2020-02-20 00:00:00",  # The start date of
                                  recurrence. Required.
                                "to": "2020-02-20 00:00:00"  # Optional. The end date
                                  of recurrence.
                            },
                            "status": "str"  # Optional. The status of the export's
                              schedule. If 'Inactive', the export's schedule is paused. Known values
                              are: "Active" and "Inactive".
                        }
                    },
                    "type": "str"  # Optional. Resource type.
                }

                # response body for status code(s): 200, 201
                response == {
                    "eTag": "str",  # Optional. eTag of the resource. To handle concurrent update
                      scenario, this field will be used to determine whether the user is updating the
                      latest version or not.
                    "id": "str",  # Optional. Resource Id.
                    "name": "str",  # Optional. Resource name.
                    "properties": {
                        "definition": {
                            "dataSet": {
                                "configuration": {
                                    "columns": [
                                        "str"  # Optional. Array of column
                                          names to be included in the export. If not provided then the
                                          export will include all available columns. The available
                                          columns can vary by customer channel (see examples).
                                    ]
                                },
                                "granularity": "str"  # Optional. The granularity of
                                  rows in the export. Currently only 'Daily' is supported. "Daily"
                            },
                            "timePeriod": {
                                "from": "2020-02-20 00:00:00",  # The start date for
                                  export data. Required.
                                "to": "2020-02-20 00:00:00"  # The end date for
                                  export data. Required.
                            },
                            "timeframe": "str",  # The time frame for pulling data for
                              the export. If custom, then a specific time period must be provided.
                              Required. Known values are: "MonthToDate", "BillingMonthToDate",
                              "TheLastMonth", "TheLastBillingMonth", "WeekToDate", and "Custom".
                            "type": "str"  # The type of the export. Note that 'Usage' is
                              equivalent to 'ActualCost' and is applicable to exports that do not yet
                              provide data for charges or amortization for service reservations.
                              Required. Known values are: "Usage", "ActualCost", and "AmortizedCost".
                        },
                        "deliveryInfo": {
                            "destination": {
                                "container": "str",  # The name of the container
                                  where exports will be uploaded. If the container does not exist it
                                  will be created. Required.
                                "resourceId": "str",  # Optional. The resource id of
                                  the storage account where exports will be delivered. This is not
                                  required if a sasToken and storageAccount are specified.
                                "rootFolderPath": "str",  # Optional. The name of the
                                  directory where exports will be uploaded.
                                "sasToken": "str",  # Optional. A SAS token for the
                                  storage account. For a restricted set of Azure customers this
                                  together with storageAccount can be specified instead of resourceId.
                                  Note: the value returned by the API for this property will always be
                                  obfuscated. Returning this same obfuscated value will not result in
                                  the SAS token being updated. To update this value a new SAS token
                                  must be specified.
                                "storageAccount": "str"  # Optional. The storage
                                  account where exports will be uploaded. For a restricted set of Azure
                                  customers this together with sasToken can be specified instead of
                                  resourceId.
                            }
                        },
                        "format": "str",  # Optional. The format of the export being
                          delivered. Currently only 'Csv' is supported. "Csv"
                        "nextRunTimeEstimate": "2020-02-20 00:00:00",  # Optional. If the
                          export has an active schedule, provides an estimate of the next execution
                          time.
                        "partitionData": bool,  # Optional. If set to true, exported data
                          will be partitioned by size and placed in a blob directory together with a
                          manifest file. Note: this option is currently available only for modern
                          commerce scopes.
                        "runHistory": {
                            "value": [
                                {
                                    "eTag": "str",  # Optional. eTag of the
                                      resource. To handle concurrent update scenario, this field will
                                      be used to determine whether the user is updating the latest
                                      version or not.
                                    "id": "str",  # Optional. Resource Id.
                                    "name": "str",  # Optional. Resource name.
                                    "properties": {
                                        "error": {
                                            "code": "str",  # Optional.
                                              Error code.
                                            "message": "str"  # Optional.
                                              Error message indicating why the operation failed.
                                        },
                                        "executionType": "str",  # Optional.
                                          The type of the export execution. Known values are:
                                          "OnDemand" and "Scheduled".
                                        "fileName": "str",  # Optional. The
                                          name of the exported file.
                                        "processingEndTime": "2020-02-20
                                          00:00:00",  # Optional. The time when the export execution
                                          finished.
                                        "processingStartTime": "2020-02-20
                                          00:00:00",  # Optional. The time when export was picked up to
                                          be executed.
                                        "runSettings": {
                                            "definition": {
                                                "dataSet": {
                "configuration": {
                "columns": [
                "str"  # Optional. Array of column names
                                                              to be included in the export. If not
                                                              provided then the export will include all
                                                              available columns. The available columns
                                                              can vary by customer channel (see
                                                              examples).
                                                        ]
                                                    },
                "granularity": "str"  # Optional. The granularity
                                                      of rows in the export. Currently only 'Daily' is
                                                      supported. "Daily"
                                                },
                                                "timePeriod": {
                                                    "from":
                                                      "2020-02-20 00:00:00",  # The start date for
                                                      export data. Required.
                                                    "to":
                                                      "2020-02-20 00:00:00"  # The end date for export
                                                      data. Required.
                                                },
                                                "timeframe": "str",
                                                  # The time frame for pulling data for the export. If
                                                  custom, then a specific time period must be provided.
                                                  Required. Known values are: "MonthToDate",
                                                  "BillingMonthToDate", "TheLastMonth",
                                                  "TheLastBillingMonth", "WeekToDate", and "Custom".
                                                "type": "str"  # The
                                                  type of the export. Note that 'Usage' is equivalent
                                                  to 'ActualCost' and is applicable to exports that do
                                                  not yet provide data for charges or amortization for
                                                  service reservations. Required. Known values are:
                                                  "Usage", "ActualCost", and "AmortizedCost".
                                            },
                                            "deliveryInfo": {
                                                "destination": {
                                                    "container":
                                                      "str",  # The name of the container where exports
                                                      will be uploaded. If the container does not exist
                                                      it will be created. Required.
                                                    "resourceId":
                                                      "str",  # Optional. The resource id of the
                                                      storage account where exports will be delivered.
                                                      This is not required if a sasToken and
                                                      storageAccount are specified.
                "rootFolderPath": "str",  # Optional. The name of
                                                      the directory where exports will be uploaded.
                                                    "sasToken":
                                                      "str",  # Optional. A SAS token for the storage
                                                      account. For a restricted set of Azure customers
                                                      this together with storageAccount can be
                                                      specified instead of resourceId. Note: the value
                                                      returned by the API for this property will always
                                                      be obfuscated. Returning this same obfuscated
                                                      value will not result in the SAS token being
                                                      updated. To update this value a new SAS token
                                                      must be specified.
                "storageAccount": "str"  # Optional. The storage
                                                      account where exports will be uploaded. For a
                                                      restricted set of Azure customers this together
                                                      with sasToken can be specified instead of
                                                      resourceId.
                                                }
                                            },
                                            "format": "str",  # Optional.
                                              The format of the export being delivered. Currently only
                                              'Csv' is supported. "Csv"
                                            "nextRunTimeEstimate":
                                              "2020-02-20 00:00:00",  # Optional. If the export has an
                                              active schedule, provides an estimate of the next
                                              execution time.
                                            "partitionData": bool,  #
                                              Optional. If set to true, exported data will be
                                              partitioned by size and placed in a blob directory
                                              together with a manifest file. Note: this option is
                                              currently available only for modern commerce scopes.
                                            "runHistory": ...
                                        },
                                        "status": "str",  # Optional. The
                                          last known status of the export execution. Known values are:
                                          "Queued", "InProgress", "Completed", "Failed", "Timeout",
                                          "NewDataNotAvailable", and "DataNotAvailable".
                                        "submittedBy": "str",  # Optional.
                                          The identifier for the entity that executed the export. For
                                          OnDemand executions it is the user email. For scheduled
                                          executions it is 'System'.
                                        "submittedTime": "2020-02-20
                                          00:00:00"  # Optional. The time when export was queued to be
                                          executed.
                                    },
                                    "type": "str"  # Optional. Resource type.
                                }
                            ]
                        },
                        "schedule": {
                            "recurrence": "str",  # Optional. The schedule recurrence.
                              Known values are: "Daily", "Weekly", "Monthly", and "Annually".
                            "recurrencePeriod": {
                                "from": "2020-02-20 00:00:00",  # The start date of
                                  recurrence. Required.
                                "to": "2020-02-20 00:00:00"  # Optional. The end date
                                  of recurrence.
                            },
                            "status": "str"  # Optional. The status of the export's
                              schedule. If 'Inactive', the export's schedule is paused. Known values
                              are: "Active" and "Inactive".
                        }
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """

    @overload
    def create_or_update(
        self, scope: str, export_name: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """The operation to create or update a export. Update operation requires latest eTag to be set in
        the request. You may obtain the latest eTag by performing a get operation. Create operation
        does not require eTag.

        :param scope: The scope associated with export operations. This includes
         '/subscriptions/{subscriptionId}/' for subscription scope,
         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
         for Department scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
         for EnrollmentAccount scope,
         '/providers/Microsoft.Management/managementGroups/{managementGroupId} for Management Group
         scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
         for billingProfile scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
         for invoiceSection scope, and
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}'
         specific for partners. Required.
        :type scope: str
        :param export_name: Export Name. Required.
        :type export_name: str
        :param parameters: Parameters supplied to the CreateOrUpdate Export operation. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "eTag": "str",  # Optional. eTag of the resource. To handle concurrent update
                      scenario, this field will be used to determine whether the user is updating the
                      latest version or not.
                    "id": "str",  # Optional. Resource Id.
                    "name": "str",  # Optional. Resource name.
                    "properties": {
                        "definition": {
                            "dataSet": {
                                "configuration": {
                                    "columns": [
                                        "str"  # Optional. Array of column
                                          names to be included in the export. If not provided then the
                                          export will include all available columns. The available
                                          columns can vary by customer channel (see examples).
                                    ]
                                },
                                "granularity": "str"  # Optional. The granularity of
                                  rows in the export. Currently only 'Daily' is supported. "Daily"
                            },
                            "timePeriod": {
                                "from": "2020-02-20 00:00:00",  # The start date for
                                  export data. Required.
                                "to": "2020-02-20 00:00:00"  # The end date for
                                  export data. Required.
                            },
                            "timeframe": "str",  # The time frame for pulling data for
                              the export. If custom, then a specific time period must be provided.
                              Required. Known values are: "MonthToDate", "BillingMonthToDate",
                              "TheLastMonth", "TheLastBillingMonth", "WeekToDate", and "Custom".
                            "type": "str"  # The type of the export. Note that 'Usage' is
                              equivalent to 'ActualCost' and is applicable to exports that do not yet
                              provide data for charges or amortization for service reservations.
                              Required. Known values are: "Usage", "ActualCost", and "AmortizedCost".
                        },
                        "deliveryInfo": {
                            "destination": {
                                "container": "str",  # The name of the container
                                  where exports will be uploaded. If the container does not exist it
                                  will be created. Required.
                                "resourceId": "str",  # Optional. The resource id of
                                  the storage account where exports will be delivered. This is not
                                  required if a sasToken and storageAccount are specified.
                                "rootFolderPath": "str",  # Optional. The name of the
                                  directory where exports will be uploaded.
                                "sasToken": "str",  # Optional. A SAS token for the
                                  storage account. For a restricted set of Azure customers this
                                  together with storageAccount can be specified instead of resourceId.
                                  Note: the value returned by the API for this property will always be
                                  obfuscated. Returning this same obfuscated value will not result in
                                  the SAS token being updated. To update this value a new SAS token
                                  must be specified.
                                "storageAccount": "str"  # Optional. The storage
                                  account where exports will be uploaded. For a restricted set of Azure
                                  customers this together with sasToken can be specified instead of
                                  resourceId.
                            }
                        },
                        "format": "str",  # Optional. The format of the export being
                          delivered. Currently only 'Csv' is supported. "Csv"
                        "nextRunTimeEstimate": "2020-02-20 00:00:00",  # Optional. If the
                          export has an active schedule, provides an estimate of the next execution
                          time.
                        "partitionData": bool,  # Optional. If set to true, exported data
                          will be partitioned by size and placed in a blob directory together with a
                          manifest file. Note: this option is currently available only for modern
                          commerce scopes.
                        "runHistory": {
                            "value": [
                                {
                                    "eTag": "str",  # Optional. eTag of the
                                      resource. To handle concurrent update scenario, this field will
                                      be used to determine whether the user is updating the latest
                                      version or not.
                                    "id": "str",  # Optional. Resource Id.
                                    "name": "str",  # Optional. Resource name.
                                    "properties": {
                                        "error": {
                                            "code": "str",  # Optional.
                                              Error code.
                                            "message": "str"  # Optional.
                                              Error message indicating why the operation failed.
                                        },
                                        "executionType": "str",  # Optional.
                                          The type of the export execution. Known values are:
                                          "OnDemand" and "Scheduled".
                                        "fileName": "str",  # Optional. The
                                          name of the exported file.
                                        "processingEndTime": "2020-02-20
                                          00:00:00",  # Optional. The time when the export execution
                                          finished.
                                        "processingStartTime": "2020-02-20
                                          00:00:00",  # Optional. The time when export was picked up to
                                          be executed.
                                        "runSettings": {
                                            "definition": {
                                                "dataSet": {
                "configuration": {
                "columns": [
                "str"  # Optional. Array of column names
                                                              to be included in the export. If not
                                                              provided then the export will include all
                                                              available columns. The available columns
                                                              can vary by customer channel (see
                                                              examples).
                                                        ]
                                                    },
                "granularity": "str"  # Optional. The granularity
                                                      of rows in the export. Currently only 'Daily' is
                                                      supported. "Daily"
                                                },
                                                "timePeriod": {
                                                    "from":
                                                      "2020-02-20 00:00:00",  # The start date for
                                                      export data. Required.
                                                    "to":
                                                      "2020-02-20 00:00:00"  # The end date for export
                                                      data. Required.
                                                },
                                                "timeframe": "str",
                                                  # The time frame for pulling data for the export. If
                                                  custom, then a specific time period must be provided.
                                                  Required. Known values are: "MonthToDate",
                                                  "BillingMonthToDate", "TheLastMonth",
                                                  "TheLastBillingMonth", "WeekToDate", and "Custom".
                                                "type": "str"  # The
                                                  type of the export. Note that 'Usage' is equivalent
                                                  to 'ActualCost' and is applicable to exports that do
                                                  not yet provide data for charges or amortization for
                                                  service reservations. Required. Known values are:
                                                  "Usage", "ActualCost", and "AmortizedCost".
                                            },
                                            "deliveryInfo": {
                                                "destination": {
                                                    "container":
                                                      "str",  # The name of the container where exports
                                                      will be uploaded. If the container does not exist
                                                      it will be created. Required.
                                                    "resourceId":
                                                      "str",  # Optional. The resource id of the
                                                      storage account where exports will be delivered.
                                                      This is not required if a sasToken and
                                                      storageAccount are specified.
                "rootFolderPath": "str",  # Optional. The name of
                                                      the directory where exports will be uploaded.
                                                    "sasToken":
                                                      "str",  # Optional. A SAS token for the storage
                                                      account. For a restricted set of Azure customers
                                                      this together with storageAccount can be
                                                      specified instead of resourceId. Note: the value
                                                      returned by the API for this property will always
                                                      be obfuscated. Returning this same obfuscated
                                                      value will not result in the SAS token being
                                                      updated. To update this value a new SAS token
                                                      must be specified.
                "storageAccount": "str"  # Optional. The storage
                                                      account where exports will be uploaded. For a
                                                      restricted set of Azure customers this together
                                                      with sasToken can be specified instead of
                                                      resourceId.
                                                }
                                            },
                                            "format": "str",  # Optional.
                                              The format of the export being delivered. Currently only
                                              'Csv' is supported. "Csv"
                                            "nextRunTimeEstimate":
                                              "2020-02-20 00:00:00",  # Optional. If the export has an
                                              active schedule, provides an estimate of the next
                                              execution time.
                                            "partitionData": bool,  #
                                              Optional. If set to true, exported data will be
                                              partitioned by size and placed in a blob directory
                                              together with a manifest file. Note: this option is
                                              currently available only for modern commerce scopes.
                                            "runHistory": ...
                                        },
                                        "status": "str",  # Optional. The
                                          last known status of the export execution. Known values are:
                                          "Queued", "InProgress", "Completed", "Failed", "Timeout",
                                          "NewDataNotAvailable", and "DataNotAvailable".
                                        "submittedBy": "str",  # Optional.
                                          The identifier for the entity that executed the export. For
                                          OnDemand executions it is the user email. For scheduled
                                          executions it is 'System'.
                                        "submittedTime": "2020-02-20
                                          00:00:00"  # Optional. The time when export was queued to be
                                          executed.
                                    },
                                    "type": "str"  # Optional. Resource type.
                                }
                            ]
                        },
                        "schedule": {
                            "recurrence": "str",  # Optional. The schedule recurrence.
                              Known values are: "Daily", "Weekly", "Monthly", and "Annually".
                            "recurrencePeriod": {
                                "from": "2020-02-20 00:00:00",  # The start date of
                                  recurrence. Required.
                                "to": "2020-02-20 00:00:00"  # Optional. The end date
                                  of recurrence.
                            },
                            "status": "str"  # Optional. The status of the export's
                              schedule. If 'Inactive', the export's schedule is paused. Known values
                              are: "Active" and "Inactive".
                        }
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """

    @distributed_trace
    def create_or_update(self, scope: str, export_name: str, parameters: Union[JSON, IO], **kwargs: Any) -> JSON:
        """The operation to create or update a export. Update operation requires latest eTag to be set in
        the request. You may obtain the latest eTag by performing a get operation. Create operation
        does not require eTag.

        :param scope: The scope associated with export operations. This includes
         '/subscriptions/{subscriptionId}/' for subscription scope,
         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
         for Department scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
         for EnrollmentAccount scope,
         '/providers/Microsoft.Management/managementGroups/{managementGroupId} for Management Group
         scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
         for billingProfile scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
         for invoiceSection scope, and
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}'
         specific for partners. Required.
        :type scope: str
        :param export_name: Export Name. Required.
        :type export_name: str
        :param parameters: Parameters supplied to the CreateOrUpdate Export operation. Is either a
         model type or a IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "eTag": "str",  # Optional. eTag of the resource. To handle concurrent update
                      scenario, this field will be used to determine whether the user is updating the
                      latest version or not.
                    "id": "str",  # Optional. Resource Id.
                    "name": "str",  # Optional. Resource name.
                    "properties": {
                        "definition": {
                            "dataSet": {
                                "configuration": {
                                    "columns": [
                                        "str"  # Optional. Array of column
                                          names to be included in the export. If not provided then the
                                          export will include all available columns. The available
                                          columns can vary by customer channel (see examples).
                                    ]
                                },
                                "granularity": "str"  # Optional. The granularity of
                                  rows in the export. Currently only 'Daily' is supported. "Daily"
                            },
                            "timePeriod": {
                                "from": "2020-02-20 00:00:00",  # The start date for
                                  export data. Required.
                                "to": "2020-02-20 00:00:00"  # The end date for
                                  export data. Required.
                            },
                            "timeframe": "str",  # The time frame for pulling data for
                              the export. If custom, then a specific time period must be provided.
                              Required. Known values are: "MonthToDate", "BillingMonthToDate",
                              "TheLastMonth", "TheLastBillingMonth", "WeekToDate", and "Custom".
                            "type": "str"  # The type of the export. Note that 'Usage' is
                              equivalent to 'ActualCost' and is applicable to exports that do not yet
                              provide data for charges or amortization for service reservations.
                              Required. Known values are: "Usage", "ActualCost", and "AmortizedCost".
                        },
                        "deliveryInfo": {
                            "destination": {
                                "container": "str",  # The name of the container
                                  where exports will be uploaded. If the container does not exist it
                                  will be created. Required.
                                "resourceId": "str",  # Optional. The resource id of
                                  the storage account where exports will be delivered. This is not
                                  required if a sasToken and storageAccount are specified.
                                "rootFolderPath": "str",  # Optional. The name of the
                                  directory where exports will be uploaded.
                                "sasToken": "str",  # Optional. A SAS token for the
                                  storage account. For a restricted set of Azure customers this
                                  together with storageAccount can be specified instead of resourceId.
                                  Note: the value returned by the API for this property will always be
                                  obfuscated. Returning this same obfuscated value will not result in
                                  the SAS token being updated. To update this value a new SAS token
                                  must be specified.
                                "storageAccount": "str"  # Optional. The storage
                                  account where exports will be uploaded. For a restricted set of Azure
                                  customers this together with sasToken can be specified instead of
                                  resourceId.
                            }
                        },
                        "format": "str",  # Optional. The format of the export being
                          delivered. Currently only 'Csv' is supported. "Csv"
                        "nextRunTimeEstimate": "2020-02-20 00:00:00",  # Optional. If the
                          export has an active schedule, provides an estimate of the next execution
                          time.
                        "partitionData": bool,  # Optional. If set to true, exported data
                          will be partitioned by size and placed in a blob directory together with a
                          manifest file. Note: this option is currently available only for modern
                          commerce scopes.
                        "runHistory": {
                            "value": [
                                {
                                    "eTag": "str",  # Optional. eTag of the
                                      resource. To handle concurrent update scenario, this field will
                                      be used to determine whether the user is updating the latest
                                      version or not.
                                    "id": "str",  # Optional. Resource Id.
                                    "name": "str",  # Optional. Resource name.
                                    "properties": {
                                        "error": {
                                            "code": "str",  # Optional.
                                              Error code.
                                            "message": "str"  # Optional.
                                              Error message indicating why the operation failed.
                                        },
                                        "executionType": "str",  # Optional.
                                          The type of the export execution. Known values are:
                                          "OnDemand" and "Scheduled".
                                        "fileName": "str",  # Optional. The
                                          name of the exported file.
                                        "processingEndTime": "2020-02-20
                                          00:00:00",  # Optional. The time when the export execution
                                          finished.
                                        "processingStartTime": "2020-02-20
                                          00:00:00",  # Optional. The time when export was picked up to
                                          be executed.
                                        "runSettings": {
                                            "definition": {
                                                "dataSet": {
                "configuration": {
                "columns": [
                "str"  # Optional. Array of column names
                                                              to be included in the export. If not
                                                              provided then the export will include all
                                                              available columns. The available columns
                                                              can vary by customer channel (see
                                                              examples).
                                                        ]
                                                    },
                "granularity": "str"  # Optional. The granularity
                                                      of rows in the export. Currently only 'Daily' is
                                                      supported. "Daily"
                                                },
                                                "timePeriod": {
                                                    "from":
                                                      "2020-02-20 00:00:00",  # The start date for
                                                      export data. Required.
                                                    "to":
                                                      "2020-02-20 00:00:00"  # The end date for export
                                                      data. Required.
                                                },
                                                "timeframe": "str",
                                                  # The time frame for pulling data for the export. If
                                                  custom, then a specific time period must be provided.
                                                  Required. Known values are: "MonthToDate",
                                                  "BillingMonthToDate", "TheLastMonth",
                                                  "TheLastBillingMonth", "WeekToDate", and "Custom".
                                                "type": "str"  # The
                                                  type of the export. Note that 'Usage' is equivalent
                                                  to 'ActualCost' and is applicable to exports that do
                                                  not yet provide data for charges or amortization for
                                                  service reservations. Required. Known values are:
                                                  "Usage", "ActualCost", and "AmortizedCost".
                                            },
                                            "deliveryInfo": {
                                                "destination": {
                                                    "container":
                                                      "str",  # The name of the container where exports
                                                      will be uploaded. If the container does not exist
                                                      it will be created. Required.
                                                    "resourceId":
                                                      "str",  # Optional. The resource id of the
                                                      storage account where exports will be delivered.
                                                      This is not required if a sasToken and
                                                      storageAccount are specified.
                "rootFolderPath": "str",  # Optional. The name of
                                                      the directory where exports will be uploaded.
                                                    "sasToken":
                                                      "str",  # Optional. A SAS token for the storage
                                                      account. For a restricted set of Azure customers
                                                      this together with storageAccount can be
                                                      specified instead of resourceId. Note: the value
                                                      returned by the API for this property will always
                                                      be obfuscated. Returning this same obfuscated
                                                      value will not result in the SAS token being
                                                      updated. To update this value a new SAS token
                                                      must be specified.
                "storageAccount": "str"  # Optional. The storage
                                                      account where exports will be uploaded. For a
                                                      restricted set of Azure customers this together
                                                      with sasToken can be specified instead of
                                                      resourceId.
                                                }
                                            },
                                            "format": "str",  # Optional.
                                              The format of the export being delivered. Currently only
                                              'Csv' is supported. "Csv"
                                            "nextRunTimeEstimate":
                                              "2020-02-20 00:00:00",  # Optional. If the export has an
                                              active schedule, provides an estimate of the next
                                              execution time.
                                            "partitionData": bool,  #
                                              Optional. If set to true, exported data will be
                                              partitioned by size and placed in a blob directory
                                              together with a manifest file. Note: this option is
                                              currently available only for modern commerce scopes.
                                            "runHistory": ...
                                        },
                                        "status": "str",  # Optional. The
                                          last known status of the export execution. Known values are:
                                          "Queued", "InProgress", "Completed", "Failed", "Timeout",
                                          "NewDataNotAvailable", and "DataNotAvailable".
                                        "submittedBy": "str",  # Optional.
                                          The identifier for the entity that executed the export. For
                                          OnDemand executions it is the user email. For scheduled
                                          executions it is 'System'.
                                        "submittedTime": "2020-02-20
                                          00:00:00"  # Optional. The time when export was queued to be
                                          executed.
                                    },
                                    "type": "str"  # Optional. Resource type.
                                }
                            ]
                        },
                        "schedule": {
                            "recurrence": "str",  # Optional. The schedule recurrence.
                              Known values are: "Daily", "Weekly", "Monthly", and "Annually".
                            "recurrencePeriod": {
                                "from": "2020-02-20 00:00:00",  # The start date of
                                  recurrence. Required.
                                "to": "2020-02-20 00:00:00"  # Optional. The end date
                                  of recurrence.
                            },
                            "status": "str"  # Optional. The status of the export's
                              schedule. If 'Inactive', the export's schedule is paused. Known values
                              are: "Active" and "Inactive".
                        }
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IO, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_exports_create_or_update_request(
            scope=scope,
            export_name=export_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, scope: str, export_name: str, **kwargs: Any
    ) -> None:
        """The operation to delete a export.

        :param scope: The scope associated with export operations. This includes
         '/subscriptions/{subscriptionId}/' for subscription scope,
         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
         for Department scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
         for EnrollmentAccount scope,
         '/providers/Microsoft.Management/managementGroups/{managementGroupId} for Management Group
         scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
         for billingProfile scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
         for invoiceSection scope, and
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}'
         specific for partners. Required.
        :type scope: str
        :param export_name: Export Name. Required.
        :type export_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_exports_delete_request(
            scope=scope,
            export_name=export_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def execute(  # pylint: disable=inconsistent-return-statements
        self, scope: str, export_name: str, **kwargs: Any
    ) -> None:
        """The operation to execute an export.

        :param scope: The scope associated with export operations. This includes
         '/subscriptions/{subscriptionId}/' for subscription scope,
         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
         for Department scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
         for EnrollmentAccount scope,
         '/providers/Microsoft.Management/managementGroups/{managementGroupId} for Management Group
         scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
         for billingProfile scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
         for invoiceSection scope, and
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}'
         specific for partners. Required.
        :type scope: str
        :param export_name: Export Name. Required.
        :type export_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_exports_execute_request(
            scope=scope,
            export_name=export_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def get_execution_history(self, scope: str, export_name: str, **kwargs: Any) -> JSON:
        """The operation to get the execution history of an export for the defined scope and export name.

        :param scope: The scope associated with export operations. This includes
         '/subscriptions/{subscriptionId}/' for subscription scope,
         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
         for Department scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
         for EnrollmentAccount scope,
         '/providers/Microsoft.Management/managementGroups/{managementGroupId} for Management Group
         scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
         for billingProfile scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
         for invoiceSection scope, and
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}'
         specific for partners. Required.
        :type scope: str
        :param export_name: Export Name. Required.
        :type export_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "eTag": "str",  # Optional. eTag of the resource. To handle
                              concurrent update scenario, this field will be used to determine whether
                              the user is updating the latest version or not.
                            "id": "str",  # Optional. Resource Id.
                            "name": "str",  # Optional. Resource name.
                            "properties": {
                                "error": {
                                    "code": "str",  # Optional. Error code.
                                    "message": "str"  # Optional. Error message
                                      indicating why the operation failed.
                                },
                                "executionType": "str",  # Optional. The type of the
                                  export execution. Known values are: "OnDemand" and "Scheduled".
                                "fileName": "str",  # Optional. The name of the
                                  exported file.
                                "processingEndTime": "2020-02-20 00:00:00",  #
                                  Optional. The time when the export execution finished.
                                "processingStartTime": "2020-02-20 00:00:00",  #
                                  Optional. The time when export was picked up to be executed.
                                "runSettings": {
                                    "definition": {
                                        "dataSet": {
                                            "configuration": {
                                                "columns": [
                                                    "str"  #
                                                      Optional. Array of column names to be included in
                                                      the export. If not provided then the export will
                                                      include all available columns. The available
                                                      columns can vary by customer channel (see
                                                      examples).
                                                ]
                                            },
                                            "granularity": "str"  #
                                              Optional. The granularity of rows in the export.
                                              Currently only 'Daily' is supported. "Daily"
                                        },
                                        "timePeriod": {
                                            "from": "2020-02-20
                                              00:00:00",  # The start date for export data. Required.
                                            "to": "2020-02-20 00:00:00"
                                              # The end date for export data. Required.
                                        },
                                        "timeframe": "str",  # The time frame
                                          for pulling data for the export. If custom, then a specific
                                          time period must be provided. Required. Known values are:
                                          "MonthToDate", "BillingMonthToDate", "TheLastMonth",
                                          "TheLastBillingMonth", "WeekToDate", and "Custom".
                                        "type": "str"  # The type of the
                                          export. Note that 'Usage' is equivalent to 'ActualCost' and
                                          is applicable to exports that do not yet provide data for
                                          charges or amortization for service reservations. Required.
                                          Known values are: "Usage", "ActualCost", and "AmortizedCost".
                                    },
                                    "deliveryInfo": {
                                        "destination": {
                                            "container": "str",  # The
                                              name of the container where exports will be uploaded. If
                                              the container does not exist it will be created.
                                              Required.
                                            "resourceId": "str",  #
                                              Optional. The resource id of the storage account where
                                              exports will be delivered. This is not required if a
                                              sasToken and storageAccount are specified.
                                            "rootFolderPath": "str",  #
                                              Optional. The name of the directory where exports will be
                                              uploaded.
                                            "sasToken": "str",  #
                                              Optional. A SAS token for the storage account. For a
                                              restricted set of Azure customers this together with
                                              storageAccount can be specified instead of resourceId.
                                              Note: the value returned by the API for this property
                                              will always be obfuscated. Returning this same obfuscated
                                              value will not result in the SAS token being updated. To
                                              update this value a new SAS token must be specified.
                                            "storageAccount": "str"  #
                                              Optional. The storage account where exports will be
                                              uploaded. For a restricted set of Azure customers this
                                              together with sasToken can be specified instead of
                                              resourceId.
                                        }
                                    },
                                    "format": "str",  # Optional. The format of
                                      the export being delivered. Currently only 'Csv' is supported.
                                      "Csv"
                                    "nextRunTimeEstimate": "2020-02-20 00:00:00",
                                      # Optional. If the export has an active schedule, provides an
                                      estimate of the next execution time.
                                    "partitionData": bool,  # Optional. If set to
                                      true, exported data will be partitioned by size and placed in a
                                      blob directory together with a manifest file. Note: this option
                                      is currently available only for modern commerce scopes.
                                    "runHistory": ...
                                },
                                "status": "str",  # Optional. The last known status
                                  of the export execution. Known values are: "Queued", "InProgress",
                                  "Completed", "Failed", "Timeout", "NewDataNotAvailable", and
                                  "DataNotAvailable".
                                "submittedBy": "str",  # Optional. The identifier for
                                  the entity that executed the export. For OnDemand executions it is
                                  the user email. For scheduled executions it is 'System'.
                                "submittedTime": "2020-02-20 00:00:00"  # Optional.
                                  The time when export was queued to be executed.
                            },
                            "type": "str"  # Optional. Resource type.
                        }
                    ]
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_exports_get_execution_history_request(
            scope=scope,
            export_name=export_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class GenerateDetailedCostReportOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.costmanagement.CostManagementClient`'s
        :attr:`generate_detailed_cost_report` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def _create_operation_initial(self, scope: str, parameters: Union[JSON, IO], **kwargs: Any) -> Optional[JSON]:
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IO, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_generate_detailed_cost_report_create_operation_request(
            scope=scope,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Azure-Consumption-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-Consumption-AsyncOperation")
            )
            response_headers["Azure-AsyncOperation"] = self._deserialize(
                "str", response.headers.get("Azure-AsyncOperation")
            )
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    @overload
    def begin_create_operation(
        self, scope: str, parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        """Generates the detailed cost report for provided date range, billing period(Only enterprise
        customers) or Invoice Id asynchronously at a certain scope. Call returns a 202 with header
        Azure-Consumption-AsyncOperation providing a link to the operation created. A call on the
        operation will provide the status and if the operation is completed the blob file where
        generated detailed cost report is being stored.

        :param scope: The scope associated with usage details operations. This includes
         '/subscriptions/{subscriptionId}/' for subscription scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
         '/providers/Microsoft.Billing/departments/{departmentId}' for Department scope,
         '/providers/Microsoft.Billing/enrollmentAccounts/{enrollmentAccountId}' for EnrollmentAccount
         scope. Also, Modern Commerce Account scopes are
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for billingAccount scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
         for billingProfile scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
         for invoiceSection scope, and
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}'
         specific for partners. Required.
        :type scope: str
        :param parameters: Parameters supplied to the Create detailed cost report operation. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "billingPeriod": "str",  # Optional. Billing Period in YearMonth(e.g. 202008)
                      format. Only for legacy enterprise customers can use this. Can only have one of
                      either timePeriod or invoiceId or billingPeriod parameters. If none provided
                      current month cost is provided.
                    "customerId": "str",  # Optional. Customer Id for Modern (Invoice Id and
                      billing profile is also required for this).
                    "invoiceId": "str",  # Optional. Invoice Id for PayAsYouGo customers and
                      Modern billing profile scope. Can only have one of either timePeriod or invoiceId
                      or billingPeriod parameters. If none provided current month cost is provided.
                    "metric": "str",  # Optional. The type of the detailed report. By default
                      ActualCost is provided. Known values are: "ActualCost" and "AmortizedCost".
                    "timePeriod": {
                        "end": "str",  # The end date to pull data to. example format
                          2020-03-15. Required.
                        "start": "str"  # The start date to pull data from. example format
                          2020-03-15. Required.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The id of the long running operation.
                    "name": "str",  # Optional. The name of the long running operation.
                    "properties": {
                        "downloadUrl": "str",  # Optional. The URL to download the generated
                          report.
                        "validTill": "2020-02-20 00:00:00"  # Optional. The time at which
                          report URL becomes invalid/expires in UTC e.g. 2020-12-08T05:55:59.4394737Z.
                    },
                    "type": "str"  # Optional. The type of the long running operation.
                }
        """

    @overload
    def begin_create_operation(
        self, scope: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        """Generates the detailed cost report for provided date range, billing period(Only enterprise
        customers) or Invoice Id asynchronously at a certain scope. Call returns a 202 with header
        Azure-Consumption-AsyncOperation providing a link to the operation created. A call on the
        operation will provide the status and if the operation is completed the blob file where
        generated detailed cost report is being stored.

        :param scope: The scope associated with usage details operations. This includes
         '/subscriptions/{subscriptionId}/' for subscription scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
         '/providers/Microsoft.Billing/departments/{departmentId}' for Department scope,
         '/providers/Microsoft.Billing/enrollmentAccounts/{enrollmentAccountId}' for EnrollmentAccount
         scope. Also, Modern Commerce Account scopes are
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for billingAccount scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
         for billingProfile scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
         for invoiceSection scope, and
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}'
         specific for partners. Required.
        :type scope: str
        :param parameters: Parameters supplied to the Create detailed cost report operation. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The id of the long running operation.
                    "name": "str",  # Optional. The name of the long running operation.
                    "properties": {
                        "downloadUrl": "str",  # Optional. The URL to download the generated
                          report.
                        "validTill": "2020-02-20 00:00:00"  # Optional. The time at which
                          report URL becomes invalid/expires in UTC e.g. 2020-12-08T05:55:59.4394737Z.
                    },
                    "type": "str"  # Optional. The type of the long running operation.
                }
        """

    @distributed_trace
    def begin_create_operation(self, scope: str, parameters: Union[JSON, IO], **kwargs: Any) -> LROPoller[JSON]:
        """Generates the detailed cost report for provided date range, billing period(Only enterprise
        customers) or Invoice Id asynchronously at a certain scope. Call returns a 202 with header
        Azure-Consumption-AsyncOperation providing a link to the operation created. A call on the
        operation will provide the status and if the operation is completed the blob file where
        generated detailed cost report is being stored.

        :param scope: The scope associated with usage details operations. This includes
         '/subscriptions/{subscriptionId}/' for subscription scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
         '/providers/Microsoft.Billing/departments/{departmentId}' for Department scope,
         '/providers/Microsoft.Billing/enrollmentAccounts/{enrollmentAccountId}' for EnrollmentAccount
         scope. Also, Modern Commerce Account scopes are
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for billingAccount scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
         for billingProfile scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
         for invoiceSection scope, and
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}'
         specific for partners. Required.
        :type scope: str
        :param parameters: Parameters supplied to the Create detailed cost report operation. Is either
         a model type or a IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The id of the long running operation.
                    "name": "str",  # Optional. The name of the long running operation.
                    "properties": {
                        "downloadUrl": "str",  # Optional. The URL to download the generated
                          report.
                        "validTill": "2020-02-20 00:00:00"  # Optional. The time at which
                          report URL becomes invalid/expires in UTC e.g. 2020-12-08T05:55:59.4394737Z.
                    },
                    "type": "str"  # Optional. The type of the long running operation.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._create_operation_initial(  # type: ignore
                scope=scope,
                parameters=parameters,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: PollingMethod
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)


class GenerateDetailedCostReportOperationResultsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.costmanagement.CostManagementClient`'s
        :attr:`generate_detailed_cost_report_operation_results` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(self, operation_id: str, scope: str, **kwargs: Any) -> Optional[JSON]:
        """Get the result of the specified operation. This link is provided in the
        GenerateDetailedCostReport creation request response header.

        :param operation_id: The target operation Id. Required.
        :type operation_id: str
        :param scope: The scope associated with usage details operations. This includes
         '/subscriptions/{subscriptionId}/' for subscription scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
         '/providers/Microsoft.Billing/departments/{departmentId}' for Department scope,
         '/providers/Microsoft.Billing/enrollmentAccounts/{enrollmentAccountId}' for EnrollmentAccount
         scope. Also, Modern Commerce Account scopes are
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for billingAccount scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
         for billingProfile scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
         for invoiceSection scope, and
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}'
         specific for partners. Required.
        :type scope: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional. The id of the long running operation.
                    "name": "str",  # Optional. The name of the long running operation.
                    "properties": {
                        "downloadUrl": "str",  # Optional. The URL to download the generated
                          report.
                        "validTill": "2020-02-20 00:00:00"  # Optional. The time at which
                          report URL becomes invalid/expires in UTC e.g. 2020-12-08T05:55:59.4394737Z.
                    },
                    "type": "str"  # Optional. The type of the long running operation.
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_generate_detailed_cost_report_operation_results_get_request(
            operation_id=operation_id,
            scope=scope,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized


class GenerateDetailedCostReportOperationStatusOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.costmanagement.CostManagementClient`'s
        :attr:`generate_detailed_cost_report_operation_status` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(self, operation_id: str, scope: str, **kwargs: Any) -> JSON:
        """Get the status of the specified operation. This link is provided in the
        GenerateDetailedCostReport creation request response header.

        :param operation_id: The target operation Id. Required.
        :type operation_id: str
        :param scope: The scope associated with usage details operations. This includes
         '/subscriptions/{subscriptionId}/' for subscription scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
         '/providers/Microsoft.Billing/departments/{departmentId}' for Department scope,
         '/providers/Microsoft.Billing/enrollmentAccounts/{enrollmentAccountId}' for EnrollmentAccount
         scope. Also, Modern Commerce Account scopes are
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for billingAccount scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
         for billingProfile scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
         for invoiceSection scope, and
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}'
         specific for partners. Required.
        :type scope: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "error": {
                        "code": "str",  # Optional. Error code.
                        "message": "str"  # Optional. Error message indicating why the
                          operation failed.
                    },
                    "id": "str",  # Optional. The id of the long running operation.
                    "name": "str",  # Optional. The name of the long running operation.
                    "properties": {
                        "downloadUrl": "str",  # Optional. The URL to download the generated
                          report.
                        "validTill": "2020-02-20 00:00:00"  # Optional. The time at which
                          report URL becomes invalid/expires in UTC e.g. 2020-12-08T05:55:59.4394737Z.
                    },
                    "status": {
                        "status": "str"  # Optional. The status of the long running
                          operation. Known values are: "InProgress", "Completed", "Failed", "Queued",
                          "NoDataFound", "ReadyToDownload", and "TimedOut".
                    },
                    "type": "str"  # Optional. The type of the long running operation.
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_generate_detailed_cost_report_operation_status_get_request(
            operation_id=operation_id,
            scope=scope,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class ViewsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.costmanagement.CostManagementClient`'s
        :attr:`views` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> Iterable[JSON]:
        """Lists all views by tenant and object.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "eTag": "str",  # Optional. eTag of the resource. To handle concurrent update
                      scenario, this field will be used to determine whether the user is updating the
                      latest version or not.
                    "id": "str",  # Optional. Resource Id.
                    "name": "str",  # Optional. Resource name.
                    "properties": {
                        "accumulated": "str",  # Optional. Show costs accumulated over time.
                          Known values are: "true" and "false".
                        "chart": "str",  # Optional. Chart type of the main view in Cost
                          Analysis. Required. Known values are: "Area", "Line", "StackedColumn",
                          "GroupedColumn", and "Table".
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Date the user
                          created this view.
                        "currency": "str",  # Optional. Currency of the current view.
                        "dateRange": "str",  # Optional. Date range of the current view.
                        "displayName": "str",  # Optional. User input name of the view.
                          Required.
                        "kpis": [
                            {
                                "enabled": bool,  # Optional. show the KPI in the
                                  UI?.
                                "id": "str",  # Optional. ID of resource related to
                                  metric (budget).
                                "type": "str"  # Optional. KPI type (Forecast,
                                  Budget). Known values are: "Forecast" and "Budget".
                            }
                        ],
                        "metric": "str",  # Optional. Metric to use when displaying costs.
                          Known values are: "ActualCost", "AmortizedCost", and "AHUB".
                        "modifiedOn": "2020-02-20 00:00:00",  # Optional. Date when the user
                          last modified this view.
                        "pivots": [
                            {
                                "name": "str",  # Optional. Data field to show in
                                  view.
                                "type": "str"  # Optional. Data type to show in view.
                                  Known values are: "Dimension" and "TagKey".
                            }
                        ],
                        "query": {
                            "dataSet": {
                                "aggregation": {
                                    "str": {
                                        "function": "str",  # The name of the
                                          aggregation function to use. Required. "Sum"
                                        "name": "str"  # The name of the
                                          column to aggregate. Required.
                                    }
                                },
                                "configuration": {
                                    "columns": [
                                        "str"  # Optional. Array of column
                                          names to be included in the report. Any valid report column
                                          name is allowed. If not provided, then report includes all
                                          columns.
                                    ]
                                },
                                "filter": {
                                    "and": [
                                        ...
                                    ],
                                    "dimensions": {
                                        "name": "str",  # The name of the
                                          column to use in comparison. Required.
                                        "operator": "str",  # The operator to
                                          use for comparison. Required. Known values are: "In" and
                                          "Contains".
                                        "values": [
                                            "str"  # Array of values to
                                              use for comparison. Required.
                                        ]
                                    },
                                    "or": [
                                        ...
                                    ],
                                    "tags": {
                                        "name": "str",  # The name of the
                                          column to use in comparison. Required.
                                        "operator": "str",  # The operator to
                                          use for comparison. Required. Known values are: "In" and
                                          "Contains".
                                        "values": [
                                            "str"  # Array of values to
                                              use for comparison. Required.
                                        ]
                                    }
                                },
                                "granularity": "str",  # Optional. The granularity of
                                  rows in the report. Known values are: "Daily" and "Monthly".
                                "grouping": [
                                    {
                                        "name": "str",  # The name of the
                                          column to group. This version supports subscription lowest
                                          possible grain. Required.
                                        "type": "str"  # Has type of the
                                          column to group. Required. Known values are: "Tag" and
                                          "Dimension".
                                    }
                                ],
                                "sorting": [
                                    {
                                        "direction": "str",  # Optional.
                                          Direction of sort. Known values are: "Ascending" and
                                          "Descending".
                                        "name": "str"  # The name of the
                                          column to sort. Required.
                                    }
                                ]
                            },
                            "includeMonetaryCommitment": bool,  # Optional. If true,
                              report includes monetary commitment.
                            "timePeriod": {
                                "from": "2020-02-20 00:00:00",  # The start date to
                                  pull data from. Required.
                                "to": "2020-02-20 00:00:00"  # The end date to pull
                                  data to. Required.
                            },
                            "timeframe": "str",  # The time frame for pulling data for
                              the report. If custom, then a specific time period must be provided.
                              Required. Known values are: "WeekToDate", "MonthToDate", "YearToDate",
                              and "Custom".
                            "type": "str"  # The type of the report. Usage represents
                              actual usage, forecast represents forecasted data and UsageAndForecast
                              represents both usage and forecasted data. Actual usage and forecasted
                              data can be differentiated based on dates. Required. "Usage"
                        },
                        "scope": "str"  # Optional. Cost Management scope to save the view
                          on. This includes 'subscriptions/{subscriptionId}' for subscription scope,
                          'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for
                          resourceGroup scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing
                          Account scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
                          for Department scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
                          for EnrollmentAccount scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
                          for BillingProfile scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
                          for InvoiceSection scope,
                          'providers/Microsoft.Management/managementGroups/{managementGroupId}' for
                          Management Group scope,
                          '/providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}'
                          for ExternalBillingAccount scope, and
                          '/providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}'
                          for ExternalSubscription scope.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_views_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_by_scope(self, scope: str, **kwargs: Any) -> Iterable[JSON]:
        """Lists all views at the given scope.

        :param scope: The scope associated with view operations. This includes
         'subscriptions/{subscriptionId}' for subscription scope,
         'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
         Department scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
         for EnrollmentAccount scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
         for BillingProfile scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
         for InvoiceSection scope, 'providers/Microsoft.Management/managementGroups/{managementGroupId}'
         for Management Group scope,
         'providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}' for
         External Billing Account scope and
         'providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}' for
         External Subscription scope. Required.
        :type scope: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "eTag": "str",  # Optional. eTag of the resource. To handle concurrent update
                      scenario, this field will be used to determine whether the user is updating the
                      latest version or not.
                    "id": "str",  # Optional. Resource Id.
                    "name": "str",  # Optional. Resource name.
                    "properties": {
                        "accumulated": "str",  # Optional. Show costs accumulated over time.
                          Known values are: "true" and "false".
                        "chart": "str",  # Optional. Chart type of the main view in Cost
                          Analysis. Required. Known values are: "Area", "Line", "StackedColumn",
                          "GroupedColumn", and "Table".
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Date the user
                          created this view.
                        "currency": "str",  # Optional. Currency of the current view.
                        "dateRange": "str",  # Optional. Date range of the current view.
                        "displayName": "str",  # Optional. User input name of the view.
                          Required.
                        "kpis": [
                            {
                                "enabled": bool,  # Optional. show the KPI in the
                                  UI?.
                                "id": "str",  # Optional. ID of resource related to
                                  metric (budget).
                                "type": "str"  # Optional. KPI type (Forecast,
                                  Budget). Known values are: "Forecast" and "Budget".
                            }
                        ],
                        "metric": "str",  # Optional. Metric to use when displaying costs.
                          Known values are: "ActualCost", "AmortizedCost", and "AHUB".
                        "modifiedOn": "2020-02-20 00:00:00",  # Optional. Date when the user
                          last modified this view.
                        "pivots": [
                            {
                                "name": "str",  # Optional. Data field to show in
                                  view.
                                "type": "str"  # Optional. Data type to show in view.
                                  Known values are: "Dimension" and "TagKey".
                            }
                        ],
                        "query": {
                            "dataSet": {
                                "aggregation": {
                                    "str": {
                                        "function": "str",  # The name of the
                                          aggregation function to use. Required. "Sum"
                                        "name": "str"  # The name of the
                                          column to aggregate. Required.
                                    }
                                },
                                "configuration": {
                                    "columns": [
                                        "str"  # Optional. Array of column
                                          names to be included in the report. Any valid report column
                                          name is allowed. If not provided, then report includes all
                                          columns.
                                    ]
                                },
                                "filter": {
                                    "and": [
                                        ...
                                    ],
                                    "dimensions": {
                                        "name": "str",  # The name of the
                                          column to use in comparison. Required.
                                        "operator": "str",  # The operator to
                                          use for comparison. Required. Known values are: "In" and
                                          "Contains".
                                        "values": [
                                            "str"  # Array of values to
                                              use for comparison. Required.
                                        ]
                                    },
                                    "or": [
                                        ...
                                    ],
                                    "tags": {
                                        "name": "str",  # The name of the
                                          column to use in comparison. Required.
                                        "operator": "str",  # The operator to
                                          use for comparison. Required. Known values are: "In" and
                                          "Contains".
                                        "values": [
                                            "str"  # Array of values to
                                              use for comparison. Required.
                                        ]
                                    }
                                },
                                "granularity": "str",  # Optional. The granularity of
                                  rows in the report. Known values are: "Daily" and "Monthly".
                                "grouping": [
                                    {
                                        "name": "str",  # The name of the
                                          column to group. This version supports subscription lowest
                                          possible grain. Required.
                                        "type": "str"  # Has type of the
                                          column to group. Required. Known values are: "Tag" and
                                          "Dimension".
                                    }
                                ],
                                "sorting": [
                                    {
                                        "direction": "str",  # Optional.
                                          Direction of sort. Known values are: "Ascending" and
                                          "Descending".
                                        "name": "str"  # The name of the
                                          column to sort. Required.
                                    }
                                ]
                            },
                            "includeMonetaryCommitment": bool,  # Optional. If true,
                              report includes monetary commitment.
                            "timePeriod": {
                                "from": "2020-02-20 00:00:00",  # The start date to
                                  pull data from. Required.
                                "to": "2020-02-20 00:00:00"  # The end date to pull
                                  data to. Required.
                            },
                            "timeframe": "str",  # The time frame for pulling data for
                              the report. If custom, then a specific time period must be provided.
                              Required. Known values are: "WeekToDate", "MonthToDate", "YearToDate",
                              and "Custom".
                            "type": "str"  # The type of the report. Usage represents
                              actual usage, forecast represents forecasted data and UsageAndForecast
                              represents both usage and forecasted data. Actual usage and forecasted
                              data can be differentiated based on dates. Required. "Usage"
                        },
                        "scope": "str"  # Optional. Cost Management scope to save the view
                          on. This includes 'subscriptions/{subscriptionId}' for subscription scope,
                          'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for
                          resourceGroup scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing
                          Account scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
                          for Department scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
                          for EnrollmentAccount scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
                          for BillingProfile scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
                          for InvoiceSection scope,
                          'providers/Microsoft.Management/managementGroups/{managementGroupId}' for
                          Management Group scope,
                          '/providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}'
                          for ExternalBillingAccount scope, and
                          '/providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}'
                          for ExternalSubscription scope.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_views_list_by_scope_request(
                    scope=scope,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, view_name: str, **kwargs: Any) -> JSON:
        """Gets the view by view name.

        :param view_name: View name. Required.
        :type view_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "eTag": "str",  # Optional. eTag of the resource. To handle concurrent update
                      scenario, this field will be used to determine whether the user is updating the
                      latest version or not.
                    "id": "str",  # Optional. Resource Id.
                    "name": "str",  # Optional. Resource name.
                    "properties": {
                        "accumulated": "str",  # Optional. Show costs accumulated over time.
                          Known values are: "true" and "false".
                        "chart": "str",  # Optional. Chart type of the main view in Cost
                          Analysis. Required. Known values are: "Area", "Line", "StackedColumn",
                          "GroupedColumn", and "Table".
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Date the user
                          created this view.
                        "currency": "str",  # Optional. Currency of the current view.
                        "dateRange": "str",  # Optional. Date range of the current view.
                        "displayName": "str",  # Optional. User input name of the view.
                          Required.
                        "kpis": [
                            {
                                "enabled": bool,  # Optional. show the KPI in the
                                  UI?.
                                "id": "str",  # Optional. ID of resource related to
                                  metric (budget).
                                "type": "str"  # Optional. KPI type (Forecast,
                                  Budget). Known values are: "Forecast" and "Budget".
                            }
                        ],
                        "metric": "str",  # Optional. Metric to use when displaying costs.
                          Known values are: "ActualCost", "AmortizedCost", and "AHUB".
                        "modifiedOn": "2020-02-20 00:00:00",  # Optional. Date when the user
                          last modified this view.
                        "pivots": [
                            {
                                "name": "str",  # Optional. Data field to show in
                                  view.
                                "type": "str"  # Optional. Data type to show in view.
                                  Known values are: "Dimension" and "TagKey".
                            }
                        ],
                        "query": {
                            "dataSet": {
                                "aggregation": {
                                    "str": {
                                        "function": "str",  # The name of the
                                          aggregation function to use. Required. "Sum"
                                        "name": "str"  # The name of the
                                          column to aggregate. Required.
                                    }
                                },
                                "configuration": {
                                    "columns": [
                                        "str"  # Optional. Array of column
                                          names to be included in the report. Any valid report column
                                          name is allowed. If not provided, then report includes all
                                          columns.
                                    ]
                                },
                                "filter": {
                                    "and": [
                                        ...
                                    ],
                                    "dimensions": {
                                        "name": "str",  # The name of the
                                          column to use in comparison. Required.
                                        "operator": "str",  # The operator to
                                          use for comparison. Required. Known values are: "In" and
                                          "Contains".
                                        "values": [
                                            "str"  # Array of values to
                                              use for comparison. Required.
                                        ]
                                    },
                                    "or": [
                                        ...
                                    ],
                                    "tags": {
                                        "name": "str",  # The name of the
                                          column to use in comparison. Required.
                                        "operator": "str",  # The operator to
                                          use for comparison. Required. Known values are: "In" and
                                          "Contains".
                                        "values": [
                                            "str"  # Array of values to
                                              use for comparison. Required.
                                        ]
                                    }
                                },
                                "granularity": "str",  # Optional. The granularity of
                                  rows in the report. Known values are: "Daily" and "Monthly".
                                "grouping": [
                                    {
                                        "name": "str",  # The name of the
                                          column to group. This version supports subscription lowest
                                          possible grain. Required.
                                        "type": "str"  # Has type of the
                                          column to group. Required. Known values are: "Tag" and
                                          "Dimension".
                                    }
                                ],
                                "sorting": [
                                    {
                                        "direction": "str",  # Optional.
                                          Direction of sort. Known values are: "Ascending" and
                                          "Descending".
                                        "name": "str"  # The name of the
                                          column to sort. Required.
                                    }
                                ]
                            },
                            "includeMonetaryCommitment": bool,  # Optional. If true,
                              report includes monetary commitment.
                            "timePeriod": {
                                "from": "2020-02-20 00:00:00",  # The start date to
                                  pull data from. Required.
                                "to": "2020-02-20 00:00:00"  # The end date to pull
                                  data to. Required.
                            },
                            "timeframe": "str",  # The time frame for pulling data for
                              the report. If custom, then a specific time period must be provided.
                              Required. Known values are: "WeekToDate", "MonthToDate", "YearToDate",
                              and "Custom".
                            "type": "str"  # The type of the report. Usage represents
                              actual usage, forecast represents forecasted data and UsageAndForecast
                              represents both usage and forecasted data. Actual usage and forecasted
                              data can be differentiated based on dates. Required. "Usage"
                        },
                        "scope": "str"  # Optional. Cost Management scope to save the view
                          on. This includes 'subscriptions/{subscriptionId}' for subscription scope,
                          'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for
                          resourceGroup scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing
                          Account scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
                          for Department scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
                          for EnrollmentAccount scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
                          for BillingProfile scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
                          for InvoiceSection scope,
                          'providers/Microsoft.Management/managementGroups/{managementGroupId}' for
                          Management Group scope,
                          '/providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}'
                          for ExternalBillingAccount scope, and
                          '/providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}'
                          for ExternalSubscription scope.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_views_get_request(
            view_name=view_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def create_or_update(
        self, view_name: str, parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """The operation to create or update a view. Update operation requires latest eTag to be set in
        the request. You may obtain the latest eTag by performing a get operation. Create operation
        does not require eTag.

        :param view_name: View name. Required.
        :type view_name: str
        :param parameters: Parameters supplied to the CreateOrUpdate View operation. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "eTag": "str",  # Optional. eTag of the resource. To handle concurrent update
                      scenario, this field will be used to determine whether the user is updating the
                      latest version or not.
                    "id": "str",  # Optional. Resource Id.
                    "name": "str",  # Optional. Resource name.
                    "properties": {
                        "accumulated": "str",  # Optional. Show costs accumulated over time.
                          Known values are: "true" and "false".
                        "chart": "str",  # Optional. Chart type of the main view in Cost
                          Analysis. Required. Known values are: "Area", "Line", "StackedColumn",
                          "GroupedColumn", and "Table".
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Date the user
                          created this view.
                        "currency": "str",  # Optional. Currency of the current view.
                        "dateRange": "str",  # Optional. Date range of the current view.
                        "displayName": "str",  # Optional. User input name of the view.
                          Required.
                        "kpis": [
                            {
                                "enabled": bool,  # Optional. show the KPI in the
                                  UI?.
                                "id": "str",  # Optional. ID of resource related to
                                  metric (budget).
                                "type": "str"  # Optional. KPI type (Forecast,
                                  Budget). Known values are: "Forecast" and "Budget".
                            }
                        ],
                        "metric": "str",  # Optional. Metric to use when displaying costs.
                          Known values are: "ActualCost", "AmortizedCost", and "AHUB".
                        "modifiedOn": "2020-02-20 00:00:00",  # Optional. Date when the user
                          last modified this view.
                        "pivots": [
                            {
                                "name": "str",  # Optional. Data field to show in
                                  view.
                                "type": "str"  # Optional. Data type to show in view.
                                  Known values are: "Dimension" and "TagKey".
                            }
                        ],
                        "query": {
                            "dataSet": {
                                "aggregation": {
                                    "str": {
                                        "function": "str",  # The name of the
                                          aggregation function to use. Required. "Sum"
                                        "name": "str"  # The name of the
                                          column to aggregate. Required.
                                    }
                                },
                                "configuration": {
                                    "columns": [
                                        "str"  # Optional. Array of column
                                          names to be included in the report. Any valid report column
                                          name is allowed. If not provided, then report includes all
                                          columns.
                                    ]
                                },
                                "filter": {
                                    "and": [
                                        ...
                                    ],
                                    "dimensions": {
                                        "name": "str",  # The name of the
                                          column to use in comparison. Required.
                                        "operator": "str",  # The operator to
                                          use for comparison. Required. Known values are: "In" and
                                          "Contains".
                                        "values": [
                                            "str"  # Array of values to
                                              use for comparison. Required.
                                        ]
                                    },
                                    "or": [
                                        ...
                                    ],
                                    "tags": {
                                        "name": "str",  # The name of the
                                          column to use in comparison. Required.
                                        "operator": "str",  # The operator to
                                          use for comparison. Required. Known values are: "In" and
                                          "Contains".
                                        "values": [
                                            "str"  # Array of values to
                                              use for comparison. Required.
                                        ]
                                    }
                                },
                                "granularity": "str",  # Optional. The granularity of
                                  rows in the report. Known values are: "Daily" and "Monthly".
                                "grouping": [
                                    {
                                        "name": "str",  # The name of the
                                          column to group. This version supports subscription lowest
                                          possible grain. Required.
                                        "type": "str"  # Has type of the
                                          column to group. Required. Known values are: "Tag" and
                                          "Dimension".
                                    }
                                ],
                                "sorting": [
                                    {
                                        "direction": "str",  # Optional.
                                          Direction of sort. Known values are: "Ascending" and
                                          "Descending".
                                        "name": "str"  # The name of the
                                          column to sort. Required.
                                    }
                                ]
                            },
                            "includeMonetaryCommitment": bool,  # Optional. If true,
                              report includes monetary commitment.
                            "timePeriod": {
                                "from": "2020-02-20 00:00:00",  # The start date to
                                  pull data from. Required.
                                "to": "2020-02-20 00:00:00"  # The end date to pull
                                  data to. Required.
                            },
                            "timeframe": "str",  # The time frame for pulling data for
                              the report. If custom, then a specific time period must be provided.
                              Required. Known values are: "WeekToDate", "MonthToDate", "YearToDate",
                              and "Custom".
                            "type": "str"  # The type of the report. Usage represents
                              actual usage, forecast represents forecasted data and UsageAndForecast
                              represents both usage and forecasted data. Actual usage and forecasted
                              data can be differentiated based on dates. Required. "Usage"
                        },
                        "scope": "str"  # Optional. Cost Management scope to save the view
                          on. This includes 'subscriptions/{subscriptionId}' for subscription scope,
                          'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for
                          resourceGroup scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing
                          Account scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
                          for Department scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
                          for EnrollmentAccount scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
                          for BillingProfile scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
                          for InvoiceSection scope,
                          'providers/Microsoft.Management/managementGroups/{managementGroupId}' for
                          Management Group scope,
                          '/providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}'
                          for ExternalBillingAccount scope, and
                          '/providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}'
                          for ExternalSubscription scope.
                    },
                    "type": "str"  # Optional. Resource type.
                }

                # response body for status code(s): 200, 201
                response == {
                    "eTag": "str",  # Optional. eTag of the resource. To handle concurrent update
                      scenario, this field will be used to determine whether the user is updating the
                      latest version or not.
                    "id": "str",  # Optional. Resource Id.
                    "name": "str",  # Optional. Resource name.
                    "properties": {
                        "accumulated": "str",  # Optional. Show costs accumulated over time.
                          Known values are: "true" and "false".
                        "chart": "str",  # Optional. Chart type of the main view in Cost
                          Analysis. Required. Known values are: "Area", "Line", "StackedColumn",
                          "GroupedColumn", and "Table".
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Date the user
                          created this view.
                        "currency": "str",  # Optional. Currency of the current view.
                        "dateRange": "str",  # Optional. Date range of the current view.
                        "displayName": "str",  # Optional. User input name of the view.
                          Required.
                        "kpis": [
                            {
                                "enabled": bool,  # Optional. show the KPI in the
                                  UI?.
                                "id": "str",  # Optional. ID of resource related to
                                  metric (budget).
                                "type": "str"  # Optional. KPI type (Forecast,
                                  Budget). Known values are: "Forecast" and "Budget".
                            }
                        ],
                        "metric": "str",  # Optional. Metric to use when displaying costs.
                          Known values are: "ActualCost", "AmortizedCost", and "AHUB".
                        "modifiedOn": "2020-02-20 00:00:00",  # Optional. Date when the user
                          last modified this view.
                        "pivots": [
                            {
                                "name": "str",  # Optional. Data field to show in
                                  view.
                                "type": "str"  # Optional. Data type to show in view.
                                  Known values are: "Dimension" and "TagKey".
                            }
                        ],
                        "query": {
                            "dataSet": {
                                "aggregation": {
                                    "str": {
                                        "function": "str",  # The name of the
                                          aggregation function to use. Required. "Sum"
                                        "name": "str"  # The name of the
                                          column to aggregate. Required.
                                    }
                                },
                                "configuration": {
                                    "columns": [
                                        "str"  # Optional. Array of column
                                          names to be included in the report. Any valid report column
                                          name is allowed. If not provided, then report includes all
                                          columns.
                                    ]
                                },
                                "filter": {
                                    "and": [
                                        ...
                                    ],
                                    "dimensions": {
                                        "name": "str",  # The name of the
                                          column to use in comparison. Required.
                                        "operator": "str",  # The operator to
                                          use for comparison. Required. Known values are: "In" and
                                          "Contains".
                                        "values": [
                                            "str"  # Array of values to
                                              use for comparison. Required.
                                        ]
                                    },
                                    "or": [
                                        ...
                                    ],
                                    "tags": {
                                        "name": "str",  # The name of the
                                          column to use in comparison. Required.
                                        "operator": "str",  # The operator to
                                          use for comparison. Required. Known values are: "In" and
                                          "Contains".
                                        "values": [
                                            "str"  # Array of values to
                                              use for comparison. Required.
                                        ]
                                    }
                                },
                                "granularity": "str",  # Optional. The granularity of
                                  rows in the report. Known values are: "Daily" and "Monthly".
                                "grouping": [
                                    {
                                        "name": "str",  # The name of the
                                          column to group. This version supports subscription lowest
                                          possible grain. Required.
                                        "type": "str"  # Has type of the
                                          column to group. Required. Known values are: "Tag" and
                                          "Dimension".
                                    }
                                ],
                                "sorting": [
                                    {
                                        "direction": "str",  # Optional.
                                          Direction of sort. Known values are: "Ascending" and
                                          "Descending".
                                        "name": "str"  # The name of the
                                          column to sort. Required.
                                    }
                                ]
                            },
                            "includeMonetaryCommitment": bool,  # Optional. If true,
                              report includes monetary commitment.
                            "timePeriod": {
                                "from": "2020-02-20 00:00:00",  # The start date to
                                  pull data from. Required.
                                "to": "2020-02-20 00:00:00"  # The end date to pull
                                  data to. Required.
                            },
                            "timeframe": "str",  # The time frame for pulling data for
                              the report. If custom, then a specific time period must be provided.
                              Required. Known values are: "WeekToDate", "MonthToDate", "YearToDate",
                              and "Custom".
                            "type": "str"  # The type of the report. Usage represents
                              actual usage, forecast represents forecasted data and UsageAndForecast
                              represents both usage and forecasted data. Actual usage and forecasted
                              data can be differentiated based on dates. Required. "Usage"
                        },
                        "scope": "str"  # Optional. Cost Management scope to save the view
                          on. This includes 'subscriptions/{subscriptionId}' for subscription scope,
                          'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for
                          resourceGroup scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing
                          Account scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
                          for Department scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
                          for EnrollmentAccount scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
                          for BillingProfile scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
                          for InvoiceSection scope,
                          'providers/Microsoft.Management/managementGroups/{managementGroupId}' for
                          Management Group scope,
                          '/providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}'
                          for ExternalBillingAccount scope, and
                          '/providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}'
                          for ExternalSubscription scope.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """

    @overload
    def create_or_update(
        self, view_name: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """The operation to create or update a view. Update operation requires latest eTag to be set in
        the request. You may obtain the latest eTag by performing a get operation. Create operation
        does not require eTag.

        :param view_name: View name. Required.
        :type view_name: str
        :param parameters: Parameters supplied to the CreateOrUpdate View operation. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "eTag": "str",  # Optional. eTag of the resource. To handle concurrent update
                      scenario, this field will be used to determine whether the user is updating the
                      latest version or not.
                    "id": "str",  # Optional. Resource Id.
                    "name": "str",  # Optional. Resource name.
                    "properties": {
                        "accumulated": "str",  # Optional. Show costs accumulated over time.
                          Known values are: "true" and "false".
                        "chart": "str",  # Optional. Chart type of the main view in Cost
                          Analysis. Required. Known values are: "Area", "Line", "StackedColumn",
                          "GroupedColumn", and "Table".
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Date the user
                          created this view.
                        "currency": "str",  # Optional. Currency of the current view.
                        "dateRange": "str",  # Optional. Date range of the current view.
                        "displayName": "str",  # Optional. User input name of the view.
                          Required.
                        "kpis": [
                            {
                                "enabled": bool,  # Optional. show the KPI in the
                                  UI?.
                                "id": "str",  # Optional. ID of resource related to
                                  metric (budget).
                                "type": "str"  # Optional. KPI type (Forecast,
                                  Budget). Known values are: "Forecast" and "Budget".
                            }
                        ],
                        "metric": "str",  # Optional. Metric to use when displaying costs.
                          Known values are: "ActualCost", "AmortizedCost", and "AHUB".
                        "modifiedOn": "2020-02-20 00:00:00",  # Optional. Date when the user
                          last modified this view.
                        "pivots": [
                            {
                                "name": "str",  # Optional. Data field to show in
                                  view.
                                "type": "str"  # Optional. Data type to show in view.
                                  Known values are: "Dimension" and "TagKey".
                            }
                        ],
                        "query": {
                            "dataSet": {
                                "aggregation": {
                                    "str": {
                                        "function": "str",  # The name of the
                                          aggregation function to use. Required. "Sum"
                                        "name": "str"  # The name of the
                                          column to aggregate. Required.
                                    }
                                },
                                "configuration": {
                                    "columns": [
                                        "str"  # Optional. Array of column
                                          names to be included in the report. Any valid report column
                                          name is allowed. If not provided, then report includes all
                                          columns.
                                    ]
                                },
                                "filter": {
                                    "and": [
                                        ...
                                    ],
                                    "dimensions": {
                                        "name": "str",  # The name of the
                                          column to use in comparison. Required.
                                        "operator": "str",  # The operator to
                                          use for comparison. Required. Known values are: "In" and
                                          "Contains".
                                        "values": [
                                            "str"  # Array of values to
                                              use for comparison. Required.
                                        ]
                                    },
                                    "or": [
                                        ...
                                    ],
                                    "tags": {
                                        "name": "str",  # The name of the
                                          column to use in comparison. Required.
                                        "operator": "str",  # The operator to
                                          use for comparison. Required. Known values are: "In" and
                                          "Contains".
                                        "values": [
                                            "str"  # Array of values to
                                              use for comparison. Required.
                                        ]
                                    }
                                },
                                "granularity": "str",  # Optional. The granularity of
                                  rows in the report. Known values are: "Daily" and "Monthly".
                                "grouping": [
                                    {
                                        "name": "str",  # The name of the
                                          column to group. This version supports subscription lowest
                                          possible grain. Required.
                                        "type": "str"  # Has type of the
                                          column to group. Required. Known values are: "Tag" and
                                          "Dimension".
                                    }
                                ],
                                "sorting": [
                                    {
                                        "direction": "str",  # Optional.
                                          Direction of sort. Known values are: "Ascending" and
                                          "Descending".
                                        "name": "str"  # The name of the
                                          column to sort. Required.
                                    }
                                ]
                            },
                            "includeMonetaryCommitment": bool,  # Optional. If true,
                              report includes monetary commitment.
                            "timePeriod": {
                                "from": "2020-02-20 00:00:00",  # The start date to
                                  pull data from. Required.
                                "to": "2020-02-20 00:00:00"  # The end date to pull
                                  data to. Required.
                            },
                            "timeframe": "str",  # The time frame for pulling data for
                              the report. If custom, then a specific time period must be provided.
                              Required. Known values are: "WeekToDate", "MonthToDate", "YearToDate",
                              and "Custom".
                            "type": "str"  # The type of the report. Usage represents
                              actual usage, forecast represents forecasted data and UsageAndForecast
                              represents both usage and forecasted data. Actual usage and forecasted
                              data can be differentiated based on dates. Required. "Usage"
                        },
                        "scope": "str"  # Optional. Cost Management scope to save the view
                          on. This includes 'subscriptions/{subscriptionId}' for subscription scope,
                          'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for
                          resourceGroup scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing
                          Account scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
                          for Department scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
                          for EnrollmentAccount scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
                          for BillingProfile scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
                          for InvoiceSection scope,
                          'providers/Microsoft.Management/managementGroups/{managementGroupId}' for
                          Management Group scope,
                          '/providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}'
                          for ExternalBillingAccount scope, and
                          '/providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}'
                          for ExternalSubscription scope.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """

    @distributed_trace
    def create_or_update(self, view_name: str, parameters: Union[JSON, IO], **kwargs: Any) -> JSON:
        """The operation to create or update a view. Update operation requires latest eTag to be set in
        the request. You may obtain the latest eTag by performing a get operation. Create operation
        does not require eTag.

        :param view_name: View name. Required.
        :type view_name: str
        :param parameters: Parameters supplied to the CreateOrUpdate View operation. Is either a model
         type or a IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "eTag": "str",  # Optional. eTag of the resource. To handle concurrent update
                      scenario, this field will be used to determine whether the user is updating the
                      latest version or not.
                    "id": "str",  # Optional. Resource Id.
                    "name": "str",  # Optional. Resource name.
                    "properties": {
                        "accumulated": "str",  # Optional. Show costs accumulated over time.
                          Known values are: "true" and "false".
                        "chart": "str",  # Optional. Chart type of the main view in Cost
                          Analysis. Required. Known values are: "Area", "Line", "StackedColumn",
                          "GroupedColumn", and "Table".
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Date the user
                          created this view.
                        "currency": "str",  # Optional. Currency of the current view.
                        "dateRange": "str",  # Optional. Date range of the current view.
                        "displayName": "str",  # Optional. User input name of the view.
                          Required.
                        "kpis": [
                            {
                                "enabled": bool,  # Optional. show the KPI in the
                                  UI?.
                                "id": "str",  # Optional. ID of resource related to
                                  metric (budget).
                                "type": "str"  # Optional. KPI type (Forecast,
                                  Budget). Known values are: "Forecast" and "Budget".
                            }
                        ],
                        "metric": "str",  # Optional. Metric to use when displaying costs.
                          Known values are: "ActualCost", "AmortizedCost", and "AHUB".
                        "modifiedOn": "2020-02-20 00:00:00",  # Optional. Date when the user
                          last modified this view.
                        "pivots": [
                            {
                                "name": "str",  # Optional. Data field to show in
                                  view.
                                "type": "str"  # Optional. Data type to show in view.
                                  Known values are: "Dimension" and "TagKey".
                            }
                        ],
                        "query": {
                            "dataSet": {
                                "aggregation": {
                                    "str": {
                                        "function": "str",  # The name of the
                                          aggregation function to use. Required. "Sum"
                                        "name": "str"  # The name of the
                                          column to aggregate. Required.
                                    }
                                },
                                "configuration": {
                                    "columns": [
                                        "str"  # Optional. Array of column
                                          names to be included in the report. Any valid report column
                                          name is allowed. If not provided, then report includes all
                                          columns.
                                    ]
                                },
                                "filter": {
                                    "and": [
                                        ...
                                    ],
                                    "dimensions": {
                                        "name": "str",  # The name of the
                                          column to use in comparison. Required.
                                        "operator": "str",  # The operator to
                                          use for comparison. Required. Known values are: "In" and
                                          "Contains".
                                        "values": [
                                            "str"  # Array of values to
                                              use for comparison. Required.
                                        ]
                                    },
                                    "or": [
                                        ...
                                    ],
                                    "tags": {
                                        "name": "str",  # The name of the
                                          column to use in comparison. Required.
                                        "operator": "str",  # The operator to
                                          use for comparison. Required. Known values are: "In" and
                                          "Contains".
                                        "values": [
                                            "str"  # Array of values to
                                              use for comparison. Required.
                                        ]
                                    }
                                },
                                "granularity": "str",  # Optional. The granularity of
                                  rows in the report. Known values are: "Daily" and "Monthly".
                                "grouping": [
                                    {
                                        "name": "str",  # The name of the
                                          column to group. This version supports subscription lowest
                                          possible grain. Required.
                                        "type": "str"  # Has type of the
                                          column to group. Required. Known values are: "Tag" and
                                          "Dimension".
                                    }
                                ],
                                "sorting": [
                                    {
                                        "direction": "str",  # Optional.
                                          Direction of sort. Known values are: "Ascending" and
                                          "Descending".
                                        "name": "str"  # The name of the
                                          column to sort. Required.
                                    }
                                ]
                            },
                            "includeMonetaryCommitment": bool,  # Optional. If true,
                              report includes monetary commitment.
                            "timePeriod": {
                                "from": "2020-02-20 00:00:00",  # The start date to
                                  pull data from. Required.
                                "to": "2020-02-20 00:00:00"  # The end date to pull
                                  data to. Required.
                            },
                            "timeframe": "str",  # The time frame for pulling data for
                              the report. If custom, then a specific time period must be provided.
                              Required. Known values are: "WeekToDate", "MonthToDate", "YearToDate",
                              and "Custom".
                            "type": "str"  # The type of the report. Usage represents
                              actual usage, forecast represents forecasted data and UsageAndForecast
                              represents both usage and forecasted data. Actual usage and forecasted
                              data can be differentiated based on dates. Required. "Usage"
                        },
                        "scope": "str"  # Optional. Cost Management scope to save the view
                          on. This includes 'subscriptions/{subscriptionId}' for subscription scope,
                          'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for
                          resourceGroup scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing
                          Account scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
                          for Department scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
                          for EnrollmentAccount scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
                          for BillingProfile scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
                          for InvoiceSection scope,
                          'providers/Microsoft.Management/managementGroups/{managementGroupId}' for
                          Management Group scope,
                          '/providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}'
                          for ExternalBillingAccount scope, and
                          '/providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}'
                          for ExternalSubscription scope.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IO, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_views_create_or_update_request(
            view_name=view_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete(self, view_name: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """The operation to delete a view.

        :param view_name: View name. Required.
        :type view_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_views_delete_request(
            view_name=view_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def get_by_scope(self, scope: str, view_name: str, **kwargs: Any) -> JSON:
        """Gets the view for the defined scope by view name.

        :param scope: The scope associated with view operations. This includes
         'subscriptions/{subscriptionId}' for subscription scope,
         'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
         Department scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
         for EnrollmentAccount scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
         for BillingProfile scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
         for InvoiceSection scope, 'providers/Microsoft.Management/managementGroups/{managementGroupId}'
         for Management Group scope,
         'providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}' for
         External Billing Account scope and
         'providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}' for
         External Subscription scope. Required.
        :type scope: str
        :param view_name: View name. Required.
        :type view_name: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "eTag": "str",  # Optional. eTag of the resource. To handle concurrent update
                      scenario, this field will be used to determine whether the user is updating the
                      latest version or not.
                    "id": "str",  # Optional. Resource Id.
                    "name": "str",  # Optional. Resource name.
                    "properties": {
                        "accumulated": "str",  # Optional. Show costs accumulated over time.
                          Known values are: "true" and "false".
                        "chart": "str",  # Optional. Chart type of the main view in Cost
                          Analysis. Required. Known values are: "Area", "Line", "StackedColumn",
                          "GroupedColumn", and "Table".
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Date the user
                          created this view.
                        "currency": "str",  # Optional. Currency of the current view.
                        "dateRange": "str",  # Optional. Date range of the current view.
                        "displayName": "str",  # Optional. User input name of the view.
                          Required.
                        "kpis": [
                            {
                                "enabled": bool,  # Optional. show the KPI in the
                                  UI?.
                                "id": "str",  # Optional. ID of resource related to
                                  metric (budget).
                                "type": "str"  # Optional. KPI type (Forecast,
                                  Budget). Known values are: "Forecast" and "Budget".
                            }
                        ],
                        "metric": "str",  # Optional. Metric to use when displaying costs.
                          Known values are: "ActualCost", "AmortizedCost", and "AHUB".
                        "modifiedOn": "2020-02-20 00:00:00",  # Optional. Date when the user
                          last modified this view.
                        "pivots": [
                            {
                                "name": "str",  # Optional. Data field to show in
                                  view.
                                "type": "str"  # Optional. Data type to show in view.
                                  Known values are: "Dimension" and "TagKey".
                            }
                        ],
                        "query": {
                            "dataSet": {
                                "aggregation": {
                                    "str": {
                                        "function": "str",  # The name of the
                                          aggregation function to use. Required. "Sum"
                                        "name": "str"  # The name of the
                                          column to aggregate. Required.
                                    }
                                },
                                "configuration": {
                                    "columns": [
                                        "str"  # Optional. Array of column
                                          names to be included in the report. Any valid report column
                                          name is allowed. If not provided, then report includes all
                                          columns.
                                    ]
                                },
                                "filter": {
                                    "and": [
                                        ...
                                    ],
                                    "dimensions": {
                                        "name": "str",  # The name of the
                                          column to use in comparison. Required.
                                        "operator": "str",  # The operator to
                                          use for comparison. Required. Known values are: "In" and
                                          "Contains".
                                        "values": [
                                            "str"  # Array of values to
                                              use for comparison. Required.
                                        ]
                                    },
                                    "or": [
                                        ...
                                    ],
                                    "tags": {
                                        "name": "str",  # The name of the
                                          column to use in comparison. Required.
                                        "operator": "str",  # The operator to
                                          use for comparison. Required. Known values are: "In" and
                                          "Contains".
                                        "values": [
                                            "str"  # Array of values to
                                              use for comparison. Required.
                                        ]
                                    }
                                },
                                "granularity": "str",  # Optional. The granularity of
                                  rows in the report. Known values are: "Daily" and "Monthly".
                                "grouping": [
                                    {
                                        "name": "str",  # The name of the
                                          column to group. This version supports subscription lowest
                                          possible grain. Required.
                                        "type": "str"  # Has type of the
                                          column to group. Required. Known values are: "Tag" and
                                          "Dimension".
                                    }
                                ],
                                "sorting": [
                                    {
                                        "direction": "str",  # Optional.
                                          Direction of sort. Known values are: "Ascending" and
                                          "Descending".
                                        "name": "str"  # The name of the
                                          column to sort. Required.
                                    }
                                ]
                            },
                            "includeMonetaryCommitment": bool,  # Optional. If true,
                              report includes monetary commitment.
                            "timePeriod": {
                                "from": "2020-02-20 00:00:00",  # The start date to
                                  pull data from. Required.
                                "to": "2020-02-20 00:00:00"  # The end date to pull
                                  data to. Required.
                            },
                            "timeframe": "str",  # The time frame for pulling data for
                              the report. If custom, then a specific time period must be provided.
                              Required. Known values are: "WeekToDate", "MonthToDate", "YearToDate",
                              and "Custom".
                            "type": "str"  # The type of the report. Usage represents
                              actual usage, forecast represents forecasted data and UsageAndForecast
                              represents both usage and forecasted data. Actual usage and forecasted
                              data can be differentiated based on dates. Required. "Usage"
                        },
                        "scope": "str"  # Optional. Cost Management scope to save the view
                          on. This includes 'subscriptions/{subscriptionId}' for subscription scope,
                          'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for
                          resourceGroup scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing
                          Account scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
                          for Department scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
                          for EnrollmentAccount scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
                          for BillingProfile scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
                          for InvoiceSection scope,
                          'providers/Microsoft.Management/managementGroups/{managementGroupId}' for
                          Management Group scope,
                          '/providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}'
                          for ExternalBillingAccount scope, and
                          '/providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}'
                          for ExternalSubscription scope.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_views_get_by_scope_request(
            scope=scope,
            view_name=view_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def create_or_update_by_scope(
        self, scope: str, view_name: str, parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """The operation to create or update a view. Update operation requires latest eTag to be set in
        the request. You may obtain the latest eTag by performing a get operation. Create operation
        does not require eTag.

        :param scope: The scope associated with view operations. This includes
         'subscriptions/{subscriptionId}' for subscription scope,
         'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
         Department scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
         for EnrollmentAccount scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
         for BillingProfile scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
         for InvoiceSection scope, 'providers/Microsoft.Management/managementGroups/{managementGroupId}'
         for Management Group scope,
         'providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}' for
         External Billing Account scope and
         'providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}' for
         External Subscription scope. Required.
        :type scope: str
        :param view_name: View name. Required.
        :type view_name: str
        :param parameters: Parameters supplied to the CreateOrUpdate View operation. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "eTag": "str",  # Optional. eTag of the resource. To handle concurrent update
                      scenario, this field will be used to determine whether the user is updating the
                      latest version or not.
                    "id": "str",  # Optional. Resource Id.
                    "name": "str",  # Optional. Resource name.
                    "properties": {
                        "accumulated": "str",  # Optional. Show costs accumulated over time.
                          Known values are: "true" and "false".
                        "chart": "str",  # Optional. Chart type of the main view in Cost
                          Analysis. Required. Known values are: "Area", "Line", "StackedColumn",
                          "GroupedColumn", and "Table".
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Date the user
                          created this view.
                        "currency": "str",  # Optional. Currency of the current view.
                        "dateRange": "str",  # Optional. Date range of the current view.
                        "displayName": "str",  # Optional. User input name of the view.
                          Required.
                        "kpis": [
                            {
                                "enabled": bool,  # Optional. show the KPI in the
                                  UI?.
                                "id": "str",  # Optional. ID of resource related to
                                  metric (budget).
                                "type": "str"  # Optional. KPI type (Forecast,
                                  Budget). Known values are: "Forecast" and "Budget".
                            }
                        ],
                        "metric": "str",  # Optional. Metric to use when displaying costs.
                          Known values are: "ActualCost", "AmortizedCost", and "AHUB".
                        "modifiedOn": "2020-02-20 00:00:00",  # Optional. Date when the user
                          last modified this view.
                        "pivots": [
                            {
                                "name": "str",  # Optional. Data field to show in
                                  view.
                                "type": "str"  # Optional. Data type to show in view.
                                  Known values are: "Dimension" and "TagKey".
                            }
                        ],
                        "query": {
                            "dataSet": {
                                "aggregation": {
                                    "str": {
                                        "function": "str",  # The name of the
                                          aggregation function to use. Required. "Sum"
                                        "name": "str"  # The name of the
                                          column to aggregate. Required.
                                    }
                                },
                                "configuration": {
                                    "columns": [
                                        "str"  # Optional. Array of column
                                          names to be included in the report. Any valid report column
                                          name is allowed. If not provided, then report includes all
                                          columns.
                                    ]
                                },
                                "filter": {
                                    "and": [
                                        ...
                                    ],
                                    "dimensions": {
                                        "name": "str",  # The name of the
                                          column to use in comparison. Required.
                                        "operator": "str",  # The operator to
                                          use for comparison. Required. Known values are: "In" and
                                          "Contains".
                                        "values": [
                                            "str"  # Array of values to
                                              use for comparison. Required.
                                        ]
                                    },
                                    "or": [
                                        ...
                                    ],
                                    "tags": {
                                        "name": "str",  # The name of the
                                          column to use in comparison. Required.
                                        "operator": "str",  # The operator to
                                          use for comparison. Required. Known values are: "In" and
                                          "Contains".
                                        "values": [
                                            "str"  # Array of values to
                                              use for comparison. Required.
                                        ]
                                    }
                                },
                                "granularity": "str",  # Optional. The granularity of
                                  rows in the report. Known values are: "Daily" and "Monthly".
                                "grouping": [
                                    {
                                        "name": "str",  # The name of the
                                          column to group. This version supports subscription lowest
                                          possible grain. Required.
                                        "type": "str"  # Has type of the
                                          column to group. Required. Known values are: "Tag" and
                                          "Dimension".
                                    }
                                ],
                                "sorting": [
                                    {
                                        "direction": "str",  # Optional.
                                          Direction of sort. Known values are: "Ascending" and
                                          "Descending".
                                        "name": "str"  # The name of the
                                          column to sort. Required.
                                    }
                                ]
                            },
                            "includeMonetaryCommitment": bool,  # Optional. If true,
                              report includes monetary commitment.
                            "timePeriod": {
                                "from": "2020-02-20 00:00:00",  # The start date to
                                  pull data from. Required.
                                "to": "2020-02-20 00:00:00"  # The end date to pull
                                  data to. Required.
                            },
                            "timeframe": "str",  # The time frame for pulling data for
                              the report. If custom, then a specific time period must be provided.
                              Required. Known values are: "WeekToDate", "MonthToDate", "YearToDate",
                              and "Custom".
                            "type": "str"  # The type of the report. Usage represents
                              actual usage, forecast represents forecasted data and UsageAndForecast
                              represents both usage and forecasted data. Actual usage and forecasted
                              data can be differentiated based on dates. Required. "Usage"
                        },
                        "scope": "str"  # Optional. Cost Management scope to save the view
                          on. This includes 'subscriptions/{subscriptionId}' for subscription scope,
                          'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for
                          resourceGroup scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing
                          Account scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
                          for Department scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
                          for EnrollmentAccount scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
                          for BillingProfile scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
                          for InvoiceSection scope,
                          'providers/Microsoft.Management/managementGroups/{managementGroupId}' for
                          Management Group scope,
                          '/providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}'
                          for ExternalBillingAccount scope, and
                          '/providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}'
                          for ExternalSubscription scope.
                    },
                    "type": "str"  # Optional. Resource type.
                }

                # response body for status code(s): 200, 201
                response == {
                    "eTag": "str",  # Optional. eTag of the resource. To handle concurrent update
                      scenario, this field will be used to determine whether the user is updating the
                      latest version or not.
                    "id": "str",  # Optional. Resource Id.
                    "name": "str",  # Optional. Resource name.
                    "properties": {
                        "accumulated": "str",  # Optional. Show costs accumulated over time.
                          Known values are: "true" and "false".
                        "chart": "str",  # Optional. Chart type of the main view in Cost
                          Analysis. Required. Known values are: "Area", "Line", "StackedColumn",
                          "GroupedColumn", and "Table".
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Date the user
                          created this view.
                        "currency": "str",  # Optional. Currency of the current view.
                        "dateRange": "str",  # Optional. Date range of the current view.
                        "displayName": "str",  # Optional. User input name of the view.
                          Required.
                        "kpis": [
                            {
                                "enabled": bool,  # Optional. show the KPI in the
                                  UI?.
                                "id": "str",  # Optional. ID of resource related to
                                  metric (budget).
                                "type": "str"  # Optional. KPI type (Forecast,
                                  Budget). Known values are: "Forecast" and "Budget".
                            }
                        ],
                        "metric": "str",  # Optional. Metric to use when displaying costs.
                          Known values are: "ActualCost", "AmortizedCost", and "AHUB".
                        "modifiedOn": "2020-02-20 00:00:00",  # Optional. Date when the user
                          last modified this view.
                        "pivots": [
                            {
                                "name": "str",  # Optional. Data field to show in
                                  view.
                                "type": "str"  # Optional. Data type to show in view.
                                  Known values are: "Dimension" and "TagKey".
                            }
                        ],
                        "query": {
                            "dataSet": {
                                "aggregation": {
                                    "str": {
                                        "function": "str",  # The name of the
                                          aggregation function to use. Required. "Sum"
                                        "name": "str"  # The name of the
                                          column to aggregate. Required.
                                    }
                                },
                                "configuration": {
                                    "columns": [
                                        "str"  # Optional. Array of column
                                          names to be included in the report. Any valid report column
                                          name is allowed. If not provided, then report includes all
                                          columns.
                                    ]
                                },
                                "filter": {
                                    "and": [
                                        ...
                                    ],
                                    "dimensions": {
                                        "name": "str",  # The name of the
                                          column to use in comparison. Required.
                                        "operator": "str",  # The operator to
                                          use for comparison. Required. Known values are: "In" and
                                          "Contains".
                                        "values": [
                                            "str"  # Array of values to
                                              use for comparison. Required.
                                        ]
                                    },
                                    "or": [
                                        ...
                                    ],
                                    "tags": {
                                        "name": "str",  # The name of the
                                          column to use in comparison. Required.
                                        "operator": "str",  # The operator to
                                          use for comparison. Required. Known values are: "In" and
                                          "Contains".
                                        "values": [
                                            "str"  # Array of values to
                                              use for comparison. Required.
                                        ]
                                    }
                                },
                                "granularity": "str",  # Optional. The granularity of
                                  rows in the report. Known values are: "Daily" and "Monthly".
                                "grouping": [
                                    {
                                        "name": "str",  # The name of the
                                          column to group. This version supports subscription lowest
                                          possible grain. Required.
                                        "type": "str"  # Has type of the
                                          column to group. Required. Known values are: "Tag" and
                                          "Dimension".
                                    }
                                ],
                                "sorting": [
                                    {
                                        "direction": "str",  # Optional.
                                          Direction of sort. Known values are: "Ascending" and
                                          "Descending".
                                        "name": "str"  # The name of the
                                          column to sort. Required.
                                    }
                                ]
                            },
                            "includeMonetaryCommitment": bool,  # Optional. If true,
                              report includes monetary commitment.
                            "timePeriod": {
                                "from": "2020-02-20 00:00:00",  # The start date to
                                  pull data from. Required.
                                "to": "2020-02-20 00:00:00"  # The end date to pull
                                  data to. Required.
                            },
                            "timeframe": "str",  # The time frame for pulling data for
                              the report. If custom, then a specific time period must be provided.
                              Required. Known values are: "WeekToDate", "MonthToDate", "YearToDate",
                              and "Custom".
                            "type": "str"  # The type of the report. Usage represents
                              actual usage, forecast represents forecasted data and UsageAndForecast
                              represents both usage and forecasted data. Actual usage and forecasted
                              data can be differentiated based on dates. Required. "Usage"
                        },
                        "scope": "str"  # Optional. Cost Management scope to save the view
                          on. This includes 'subscriptions/{subscriptionId}' for subscription scope,
                          'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for
                          resourceGroup scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing
                          Account scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
                          for Department scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
                          for EnrollmentAccount scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
                          for BillingProfile scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
                          for InvoiceSection scope,
                          'providers/Microsoft.Management/managementGroups/{managementGroupId}' for
                          Management Group scope,
                          '/providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}'
                          for ExternalBillingAccount scope, and
                          '/providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}'
                          for ExternalSubscription scope.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """

    @overload
    def create_or_update_by_scope(
        self, scope: str, view_name: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """The operation to create or update a view. Update operation requires latest eTag to be set in
        the request. You may obtain the latest eTag by performing a get operation. Create operation
        does not require eTag.

        :param scope: The scope associated with view operations. This includes
         'subscriptions/{subscriptionId}' for subscription scope,
         'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
         Department scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
         for EnrollmentAccount scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
         for BillingProfile scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
         for InvoiceSection scope, 'providers/Microsoft.Management/managementGroups/{managementGroupId}'
         for Management Group scope,
         'providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}' for
         External Billing Account scope and
         'providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}' for
         External Subscription scope. Required.
        :type scope: str
        :param view_name: View name. Required.
        :type view_name: str
        :param parameters: Parameters supplied to the CreateOrUpdate View operation. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "eTag": "str",  # Optional. eTag of the resource. To handle concurrent update
                      scenario, this field will be used to determine whether the user is updating the
                      latest version or not.
                    "id": "str",  # Optional. Resource Id.
                    "name": "str",  # Optional. Resource name.
                    "properties": {
                        "accumulated": "str",  # Optional. Show costs accumulated over time.
                          Known values are: "true" and "false".
                        "chart": "str",  # Optional. Chart type of the main view in Cost
                          Analysis. Required. Known values are: "Area", "Line", "StackedColumn",
                          "GroupedColumn", and "Table".
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Date the user
                          created this view.
                        "currency": "str",  # Optional. Currency of the current view.
                        "dateRange": "str",  # Optional. Date range of the current view.
                        "displayName": "str",  # Optional. User input name of the view.
                          Required.
                        "kpis": [
                            {
                                "enabled": bool,  # Optional. show the KPI in the
                                  UI?.
                                "id": "str",  # Optional. ID of resource related to
                                  metric (budget).
                                "type": "str"  # Optional. KPI type (Forecast,
                                  Budget). Known values are: "Forecast" and "Budget".
                            }
                        ],
                        "metric": "str",  # Optional. Metric to use when displaying costs.
                          Known values are: "ActualCost", "AmortizedCost", and "AHUB".
                        "modifiedOn": "2020-02-20 00:00:00",  # Optional. Date when the user
                          last modified this view.
                        "pivots": [
                            {
                                "name": "str",  # Optional. Data field to show in
                                  view.
                                "type": "str"  # Optional. Data type to show in view.
                                  Known values are: "Dimension" and "TagKey".
                            }
                        ],
                        "query": {
                            "dataSet": {
                                "aggregation": {
                                    "str": {
                                        "function": "str",  # The name of the
                                          aggregation function to use. Required. "Sum"
                                        "name": "str"  # The name of the
                                          column to aggregate. Required.
                                    }
                                },
                                "configuration": {
                                    "columns": [
                                        "str"  # Optional. Array of column
                                          names to be included in the report. Any valid report column
                                          name is allowed. If not provided, then report includes all
                                          columns.
                                    ]
                                },
                                "filter": {
                                    "and": [
                                        ...
                                    ],
                                    "dimensions": {
                                        "name": "str",  # The name of the
                                          column to use in comparison. Required.
                                        "operator": "str",  # The operator to
                                          use for comparison. Required. Known values are: "In" and
                                          "Contains".
                                        "values": [
                                            "str"  # Array of values to
                                              use for comparison. Required.
                                        ]
                                    },
                                    "or": [
                                        ...
                                    ],
                                    "tags": {
                                        "name": "str",  # The name of the
                                          column to use in comparison. Required.
                                        "operator": "str",  # The operator to
                                          use for comparison. Required. Known values are: "In" and
                                          "Contains".
                                        "values": [
                                            "str"  # Array of values to
                                              use for comparison. Required.
                                        ]
                                    }
                                },
                                "granularity": "str",  # Optional. The granularity of
                                  rows in the report. Known values are: "Daily" and "Monthly".
                                "grouping": [
                                    {
                                        "name": "str",  # The name of the
                                          column to group. This version supports subscription lowest
                                          possible grain. Required.
                                        "type": "str"  # Has type of the
                                          column to group. Required. Known values are: "Tag" and
                                          "Dimension".
                                    }
                                ],
                                "sorting": [
                                    {
                                        "direction": "str",  # Optional.
                                          Direction of sort. Known values are: "Ascending" and
                                          "Descending".
                                        "name": "str"  # The name of the
                                          column to sort. Required.
                                    }
                                ]
                            },
                            "includeMonetaryCommitment": bool,  # Optional. If true,
                              report includes monetary commitment.
                            "timePeriod": {
                                "from": "2020-02-20 00:00:00",  # The start date to
                                  pull data from. Required.
                                "to": "2020-02-20 00:00:00"  # The end date to pull
                                  data to. Required.
                            },
                            "timeframe": "str",  # The time frame for pulling data for
                              the report. If custom, then a specific time period must be provided.
                              Required. Known values are: "WeekToDate", "MonthToDate", "YearToDate",
                              and "Custom".
                            "type": "str"  # The type of the report. Usage represents
                              actual usage, forecast represents forecasted data and UsageAndForecast
                              represents both usage and forecasted data. Actual usage and forecasted
                              data can be differentiated based on dates. Required. "Usage"
                        },
                        "scope": "str"  # Optional. Cost Management scope to save the view
                          on. This includes 'subscriptions/{subscriptionId}' for subscription scope,
                          'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for
                          resourceGroup scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing
                          Account scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
                          for Department scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
                          for EnrollmentAccount scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
                          for BillingProfile scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
                          for InvoiceSection scope,
                          'providers/Microsoft.Management/managementGroups/{managementGroupId}' for
                          Management Group scope,
                          '/providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}'
                          for ExternalBillingAccount scope, and
                          '/providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}'
                          for ExternalSubscription scope.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """

    @distributed_trace
    def create_or_update_by_scope(self, scope: str, view_name: str, parameters: Union[JSON, IO], **kwargs: Any) -> JSON:
        """The operation to create or update a view. Update operation requires latest eTag to be set in
        the request. You may obtain the latest eTag by performing a get operation. Create operation
        does not require eTag.

        :param scope: The scope associated with view operations. This includes
         'subscriptions/{subscriptionId}' for subscription scope,
         'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
         Department scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
         for EnrollmentAccount scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
         for BillingProfile scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
         for InvoiceSection scope, 'providers/Microsoft.Management/managementGroups/{managementGroupId}'
         for Management Group scope,
         'providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}' for
         External Billing Account scope and
         'providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}' for
         External Subscription scope. Required.
        :type scope: str
        :param view_name: View name. Required.
        :type view_name: str
        :param parameters: Parameters supplied to the CreateOrUpdate View operation. Is either a model
         type or a IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "eTag": "str",  # Optional. eTag of the resource. To handle concurrent update
                      scenario, this field will be used to determine whether the user is updating the
                      latest version or not.
                    "id": "str",  # Optional. Resource Id.
                    "name": "str",  # Optional. Resource name.
                    "properties": {
                        "accumulated": "str",  # Optional. Show costs accumulated over time.
                          Known values are: "true" and "false".
                        "chart": "str",  # Optional. Chart type of the main view in Cost
                          Analysis. Required. Known values are: "Area", "Line", "StackedColumn",
                          "GroupedColumn", and "Table".
                        "createdOn": "2020-02-20 00:00:00",  # Optional. Date the user
                          created this view.
                        "currency": "str",  # Optional. Currency of the current view.
                        "dateRange": "str",  # Optional. Date range of the current view.
                        "displayName": "str",  # Optional. User input name of the view.
                          Required.
                        "kpis": [
                            {
                                "enabled": bool,  # Optional. show the KPI in the
                                  UI?.
                                "id": "str",  # Optional. ID of resource related to
                                  metric (budget).
                                "type": "str"  # Optional. KPI type (Forecast,
                                  Budget). Known values are: "Forecast" and "Budget".
                            }
                        ],
                        "metric": "str",  # Optional. Metric to use when displaying costs.
                          Known values are: "ActualCost", "AmortizedCost", and "AHUB".
                        "modifiedOn": "2020-02-20 00:00:00",  # Optional. Date when the user
                          last modified this view.
                        "pivots": [
                            {
                                "name": "str",  # Optional. Data field to show in
                                  view.
                                "type": "str"  # Optional. Data type to show in view.
                                  Known values are: "Dimension" and "TagKey".
                            }
                        ],
                        "query": {
                            "dataSet": {
                                "aggregation": {
                                    "str": {
                                        "function": "str",  # The name of the
                                          aggregation function to use. Required. "Sum"
                                        "name": "str"  # The name of the
                                          column to aggregate. Required.
                                    }
                                },
                                "configuration": {
                                    "columns": [
                                        "str"  # Optional. Array of column
                                          names to be included in the report. Any valid report column
                                          name is allowed. If not provided, then report includes all
                                          columns.
                                    ]
                                },
                                "filter": {
                                    "and": [
                                        ...
                                    ],
                                    "dimensions": {
                                        "name": "str",  # The name of the
                                          column to use in comparison. Required.
                                        "operator": "str",  # The operator to
                                          use for comparison. Required. Known values are: "In" and
                                          "Contains".
                                        "values": [
                                            "str"  # Array of values to
                                              use for comparison. Required.
                                        ]
                                    },
                                    "or": [
                                        ...
                                    ],
                                    "tags": {
                                        "name": "str",  # The name of the
                                          column to use in comparison. Required.
                                        "operator": "str",  # The operator to
                                          use for comparison. Required. Known values are: "In" and
                                          "Contains".
                                        "values": [
                                            "str"  # Array of values to
                                              use for comparison. Required.
                                        ]
                                    }
                                },
                                "granularity": "str",  # Optional. The granularity of
                                  rows in the report. Known values are: "Daily" and "Monthly".
                                "grouping": [
                                    {
                                        "name": "str",  # The name of the
                                          column to group. This version supports subscription lowest
                                          possible grain. Required.
                                        "type": "str"  # Has type of the
                                          column to group. Required. Known values are: "Tag" and
                                          "Dimension".
                                    }
                                ],
                                "sorting": [
                                    {
                                        "direction": "str",  # Optional.
                                          Direction of sort. Known values are: "Ascending" and
                                          "Descending".
                                        "name": "str"  # The name of the
                                          column to sort. Required.
                                    }
                                ]
                            },
                            "includeMonetaryCommitment": bool,  # Optional. If true,
                              report includes monetary commitment.
                            "timePeriod": {
                                "from": "2020-02-20 00:00:00",  # The start date to
                                  pull data from. Required.
                                "to": "2020-02-20 00:00:00"  # The end date to pull
                                  data to. Required.
                            },
                            "timeframe": "str",  # The time frame for pulling data for
                              the report. If custom, then a specific time period must be provided.
                              Required. Known values are: "WeekToDate", "MonthToDate", "YearToDate",
                              and "Custom".
                            "type": "str"  # The type of the report. Usage represents
                              actual usage, forecast represents forecasted data and UsageAndForecast
                              represents both usage and forecasted data. Actual usage and forecasted
                              data can be differentiated based on dates. Required. "Usage"
                        },
                        "scope": "str"  # Optional. Cost Management scope to save the view
                          on. This includes 'subscriptions/{subscriptionId}' for subscription scope,
                          'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for
                          resourceGroup scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing
                          Account scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
                          for Department scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
                          for EnrollmentAccount scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
                          for BillingProfile scope,
                          'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
                          for InvoiceSection scope,
                          'providers/Microsoft.Management/managementGroups/{managementGroupId}' for
                          Management Group scope,
                          '/providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}'
                          for ExternalBillingAccount scope, and
                          '/providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}'
                          for ExternalSubscription scope.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IO, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_views_create_or_update_by_scope_request(
            scope=scope,
            view_name=view_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete_by_scope(  # pylint: disable=inconsistent-return-statements
        self, scope: str, view_name: str, **kwargs: Any
    ) -> None:
        """The operation to delete a view.

        :param scope: The scope associated with view operations. This includes
         'subscriptions/{subscriptionId}' for subscription scope,
         'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}' for
         Department scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
         for EnrollmentAccount scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
         for BillingProfile scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
         for InvoiceSection scope, 'providers/Microsoft.Management/managementGroups/{managementGroupId}'
         for Management Group scope,
         'providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}' for
         External Billing Account scope and
         'providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}' for
         External Subscription scope. Required.
        :type scope: str
        :param view_name: View name. Required.
        :type view_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_views_delete_by_scope_request(
            scope=scope,
            view_name=view_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})


class AlertsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.costmanagement.CostManagementClient`'s
        :attr:`alerts` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, scope: str, **kwargs: Any) -> JSON:
        """Lists the alerts for scope defined.

        :param scope: The scope associated with alerts operations. This includes
         '/subscriptions/{subscriptionId}/' for subscription scope,
         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
         for Department scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
         for EnrollmentAccount scope,
         '/providers/Microsoft.Management/managementGroups/{managementGroupId} for Management Group
         scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
         for billingProfile scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
         for invoiceSection scope, and
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}'
         specific for partners. Required.
        :type scope: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "nextLink": "str",  # Optional. URL to get the next set of alerts results if
                      there are any.
                    "value": [
                        {
                            "eTag": "str",  # Optional. eTag of the resource. To handle
                              concurrent update scenario, this field will be used to determine whether
                              the user is updating the latest version or not.
                            "id": "str",  # Optional. Resource Id.
                            "name": "str",  # Optional. Resource name.
                            "properties": {
                                "closeTime": "str",  # Optional. dateTime in which
                                  alert was closed.
                                "costEntityId": "str",  # Optional. related budget.
                                "creationTime": "str",  # Optional. dateTime in which
                                  alert was created.
                                "definition": {
                                    "category": "str",  # Optional. Alert
                                      category. Known values are: "Cost", "Usage", "Billing", and
                                      "System".
                                    "criteria": "str",  # Optional. Criteria that
                                      triggered alert. Known values are: "CostThresholdExceeded",
                                      "UsageThresholdExceeded", "CreditThresholdApproaching",
                                      "CreditThresholdReached", "QuotaThresholdApproaching",
                                      "QuotaThresholdReached", "MultiCurrency",
                                      "ForecastCostThresholdExceeded",
                                      "ForecastUsageThresholdExceeded", "InvoiceDueDateApproaching",
                                      "InvoiceDueDateReached", "CrossCloudNewDataAvailable",
                                      "CrossCloudCollectionError", and "GeneralThresholdError".
                                    "type": "str"  # Optional. type of alert.
                                      Known values are: "Budget", "Invoice", "Credit", "Quota",
                                      "General", "xCloud", and "BudgetForecast".
                                },
                                "description": "str",  # Optional. Alert description.
                                "details": {
                                    "amount": 0.0,  # Optional. budget threshold
                                      amount.
                                    "companyName": "str",  # Optional. company
                                      name.
                                    "contactEmails": [
                                        "str"  # Optional. list of emails to
                                          contact.
                                    ],
                                    "contactGroups": [
                                        "str"  # Optional. list of action
                                          groups to broadcast to.
                                    ],
                                    "contactRoles": [
                                        "str"  # Optional. list of contact
                                          roles.
                                    ],
                                    "currentSpend": 0.0,  # Optional. current
                                      spend.
                                    "departmentName": "str",  # Optional.
                                      department name.
                                    "enrollmentEndDate": "str",  # Optional.
                                      datetime of enrollmentEndDate.
                                    "enrollmentNumber": "str",  # Optional.
                                      enrollment number.
                                    "enrollmentStartDate": "str",  # Optional.
                                      datetime of enrollmentStartDate.
                                    "invoicingThreshold": 0.0,  # Optional.
                                      invoicing threshold.
                                    "meterFilter": [
                                        {}  # Optional. array of meters to
                                          filter by.
                                    ],
                                    "operator": "str",  # Optional. operator used
                                      to compare currentSpend with amount. Known values are: "None",
                                      "EqualTo", "GreaterThan", "GreaterThanOrEqualTo", "LessThan", and
                                      "LessThanOrEqualTo".
                                    "overridingAlert": "str",  # Optional.
                                      overriding alert.
                                    "periodStartDate": "str",  # Optional.
                                      datetime of periodStartDate.
                                    "resourceFilter": [
                                        {}  # Optional. array of resources to
                                          filter by.
                                    ],
                                    "resourceGroupFilter": [
                                        {}  # Optional. array of
                                          resourceGroups to filter by.
                                    ],
                                    "tagFilter": {},  # Optional. tags to filter
                                      by.
                                    "threshold": 0.0,  # Optional. notification
                                      threshold percentage as a decimal which activated this alert.
                                    "timeGrainType": "str",  # Optional. Type of
                                      timegrain cadence. Known values are: "None", "Monthly",
                                      "Quarterly", "Annually", "BillingMonth", "BillingQuarter", and
                                      "BillingAnnual".
                                    "triggeredBy": "str",  # Optional.
                                      notificationId that triggered this alert.
                                    "unit": "str"  # Optional. unit of currency
                                      being used.
                                },
                                "modificationTime": "str",  # Optional. dateTime in
                                  which alert was last modified.
                                "source": "str",  # Optional. Source of alert. Known
                                  values are: "Preset" and "User".
                                "status": "str",  # Optional. alert status. Known
                                  values are: "None", "Active", "Overridden", "Resolved", and
                                  "Dismissed".
                                "statusModificationTime": "str",  # Optional.
                                  dateTime in which the alert status was last modified.
                                "statusModificationUserName": "str"  # Optional. User
                                  who last modified the alert.
                            },
                            "type": "str"  # Optional. Resource type.
                        }
                    ]
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_alerts_list_request(
            scope=scope,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def get(self, scope: str, alert_id: str, **kwargs: Any) -> JSON:
        """Gets the alert for the scope by alert ID.

        :param scope: The scope associated with alerts operations. This includes
         '/subscriptions/{subscriptionId}/' for subscription scope,
         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
         for Department scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
         for EnrollmentAccount scope,
         '/providers/Microsoft.Management/managementGroups/{managementGroupId} for Management Group
         scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
         for billingProfile scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
         for invoiceSection scope, and
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}'
         specific for partners. Required.
        :type scope: str
        :param alert_id: Alert ID. Required.
        :type alert_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "eTag": "str",  # Optional. eTag of the resource. To handle concurrent update
                      scenario, this field will be used to determine whether the user is updating the
                      latest version or not.
                    "id": "str",  # Optional. Resource Id.
                    "name": "str",  # Optional. Resource name.
                    "properties": {
                        "closeTime": "str",  # Optional. dateTime in which alert was closed.
                        "costEntityId": "str",  # Optional. related budget.
                        "creationTime": "str",  # Optional. dateTime in which alert was
                          created.
                        "definition": {
                            "category": "str",  # Optional. Alert category. Known values
                              are: "Cost", "Usage", "Billing", and "System".
                            "criteria": "str",  # Optional. Criteria that triggered
                              alert. Known values are: "CostThresholdExceeded",
                              "UsageThresholdExceeded", "CreditThresholdApproaching",
                              "CreditThresholdReached", "QuotaThresholdApproaching",
                              "QuotaThresholdReached", "MultiCurrency",
                              "ForecastCostThresholdExceeded", "ForecastUsageThresholdExceeded",
                              "InvoiceDueDateApproaching", "InvoiceDueDateReached",
                              "CrossCloudNewDataAvailable", "CrossCloudCollectionError", and
                              "GeneralThresholdError".
                            "type": "str"  # Optional. type of alert. Known values are:
                              "Budget", "Invoice", "Credit", "Quota", "General", "xCloud", and
                              "BudgetForecast".
                        },
                        "description": "str",  # Optional. Alert description.
                        "details": {
                            "amount": 0.0,  # Optional. budget threshold amount.
                            "companyName": "str",  # Optional. company name.
                            "contactEmails": [
                                "str"  # Optional. list of emails to contact.
                            ],
                            "contactGroups": [
                                "str"  # Optional. list of action groups to broadcast
                                  to.
                            ],
                            "contactRoles": [
                                "str"  # Optional. list of contact roles.
                            ],
                            "currentSpend": 0.0,  # Optional. current spend.
                            "departmentName": "str",  # Optional. department name.
                            "enrollmentEndDate": "str",  # Optional. datetime of
                              enrollmentEndDate.
                            "enrollmentNumber": "str",  # Optional. enrollment number.
                            "enrollmentStartDate": "str",  # Optional. datetime of
                              enrollmentStartDate.
                            "invoicingThreshold": 0.0,  # Optional. invoicing threshold.
                            "meterFilter": [
                                {}  # Optional. array of meters to filter by.
                            ],
                            "operator": "str",  # Optional. operator used to compare
                              currentSpend with amount. Known values are: "None", "EqualTo",
                              "GreaterThan", "GreaterThanOrEqualTo", "LessThan", and
                              "LessThanOrEqualTo".
                            "overridingAlert": "str",  # Optional. overriding alert.
                            "periodStartDate": "str",  # Optional. datetime of
                              periodStartDate.
                            "resourceFilter": [
                                {}  # Optional. array of resources to filter by.
                            ],
                            "resourceGroupFilter": [
                                {}  # Optional. array of resourceGroups to filter by.
                            ],
                            "tagFilter": {},  # Optional. tags to filter by.
                            "threshold": 0.0,  # Optional. notification threshold
                              percentage as a decimal which activated this alert.
                            "timeGrainType": "str",  # Optional. Type of timegrain
                              cadence. Known values are: "None", "Monthly", "Quarterly", "Annually",
                              "BillingMonth", "BillingQuarter", and "BillingAnnual".
                            "triggeredBy": "str",  # Optional. notificationId that
                              triggered this alert.
                            "unit": "str"  # Optional. unit of currency being used.
                        },
                        "modificationTime": "str",  # Optional. dateTime in which alert was
                          last modified.
                        "source": "str",  # Optional. Source of alert. Known values are:
                          "Preset" and "User".
                        "status": "str",  # Optional. alert status. Known values are: "None",
                          "Active", "Overridden", "Resolved", and "Dismissed".
                        "statusModificationTime": "str",  # Optional. dateTime in which the
                          alert status was last modified.
                        "statusModificationUserName": "str"  # Optional. User who last
                          modified the alert.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_alerts_get_request(
            scope=scope,
            alert_id=alert_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def dismiss(
        self, scope: str, alert_id: str, parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Dismisses the specified alert.

        :param scope: The scope associated with alerts operations. This includes
         '/subscriptions/{subscriptionId}/' for subscription scope,
         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
         for Department scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
         for EnrollmentAccount scope,
         '/providers/Microsoft.Management/managementGroups/{managementGroupId} for Management Group
         scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
         for billingProfile scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
         for invoiceSection scope, and
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}'
         specific for partners. Required.
        :type scope: str
        :param alert_id: Alert ID. Required.
        :type alert_id: str
        :param parameters: Parameters supplied to the Dismiss Alert operation. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "properties": {
                        "closeTime": "str",  # Optional. dateTime in which alert was closed.
                        "costEntityId": "str",  # Optional. related budget.
                        "creationTime": "str",  # Optional. dateTime in which alert was
                          created.
                        "definition": {
                            "category": "str",  # Optional. Alert category. Known values
                              are: "Cost", "Usage", "Billing", and "System".
                            "criteria": "str",  # Optional. Criteria that triggered
                              alert. Known values are: "CostThresholdExceeded",
                              "UsageThresholdExceeded", "CreditThresholdApproaching",
                              "CreditThresholdReached", "QuotaThresholdApproaching",
                              "QuotaThresholdReached", "MultiCurrency",
                              "ForecastCostThresholdExceeded", "ForecastUsageThresholdExceeded",
                              "InvoiceDueDateApproaching", "InvoiceDueDateReached",
                              "CrossCloudNewDataAvailable", "CrossCloudCollectionError", and
                              "GeneralThresholdError".
                            "type": "str"  # Optional. type of alert. Known values are:
                              "Budget", "Invoice", "Credit", "Quota", "General", "xCloud", and
                              "BudgetForecast".
                        },
                        "description": "str",  # Optional. Alert description.
                        "details": {
                            "amount": 0.0,  # Optional. budget threshold amount.
                            "companyName": "str",  # Optional. company name.
                            "contactEmails": [
                                "str"  # Optional. list of emails to contact.
                            ],
                            "contactGroups": [
                                "str"  # Optional. list of action groups to broadcast
                                  to.
                            ],
                            "contactRoles": [
                                "str"  # Optional. list of contact roles.
                            ],
                            "currentSpend": 0.0,  # Optional. current spend.
                            "departmentName": "str",  # Optional. department name.
                            "enrollmentEndDate": "str",  # Optional. datetime of
                              enrollmentEndDate.
                            "enrollmentNumber": "str",  # Optional. enrollment number.
                            "enrollmentStartDate": "str",  # Optional. datetime of
                              enrollmentStartDate.
                            "invoicingThreshold": 0.0,  # Optional. invoicing threshold.
                            "meterFilter": [
                                {}  # Optional. array of meters to filter by.
                            ],
                            "operator": "str",  # Optional. operator used to compare
                              currentSpend with amount. Known values are: "None", "EqualTo",
                              "GreaterThan", "GreaterThanOrEqualTo", "LessThan", and
                              "LessThanOrEqualTo".
                            "overridingAlert": "str",  # Optional. overriding alert.
                            "periodStartDate": "str",  # Optional. datetime of
                              periodStartDate.
                            "resourceFilter": [
                                {}  # Optional. array of resources to filter by.
                            ],
                            "resourceGroupFilter": [
                                {}  # Optional. array of resourceGroups to filter by.
                            ],
                            "tagFilter": {},  # Optional. tags to filter by.
                            "threshold": 0.0,  # Optional. notification threshold
                              percentage as a decimal which activated this alert.
                            "timeGrainType": "str",  # Optional. Type of timegrain
                              cadence. Known values are: "None", "Monthly", "Quarterly", "Annually",
                              "BillingMonth", "BillingQuarter", and "BillingAnnual".
                            "triggeredBy": "str",  # Optional. notificationId that
                              triggered this alert.
                            "unit": "str"  # Optional. unit of currency being used.
                        },
                        "modificationTime": "str",  # Optional. dateTime in which alert was
                          last modified.
                        "source": "str",  # Optional. Source of alert. Known values are:
                          "Preset" and "User".
                        "status": "str",  # Optional. alert status. Known values are: "None",
                          "Active", "Overridden", "Resolved", and "Dismissed".
                        "statusModificationTime": "str",  # Optional. dateTime in which the
                          alert status was last modified.
                        "statusModificationUserName": "str"  # Optional. User who last
                          modified the alert.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "eTag": "str",  # Optional. eTag of the resource. To handle concurrent update
                      scenario, this field will be used to determine whether the user is updating the
                      latest version or not.
                    "id": "str",  # Optional. Resource Id.
                    "name": "str",  # Optional. Resource name.
                    "properties": {
                        "closeTime": "str",  # Optional. dateTime in which alert was closed.
                        "costEntityId": "str",  # Optional. related budget.
                        "creationTime": "str",  # Optional. dateTime in which alert was
                          created.
                        "definition": {
                            "category": "str",  # Optional. Alert category. Known values
                              are: "Cost", "Usage", "Billing", and "System".
                            "criteria": "str",  # Optional. Criteria that triggered
                              alert. Known values are: "CostThresholdExceeded",
                              "UsageThresholdExceeded", "CreditThresholdApproaching",
                              "CreditThresholdReached", "QuotaThresholdApproaching",
                              "QuotaThresholdReached", "MultiCurrency",
                              "ForecastCostThresholdExceeded", "ForecastUsageThresholdExceeded",
                              "InvoiceDueDateApproaching", "InvoiceDueDateReached",
                              "CrossCloudNewDataAvailable", "CrossCloudCollectionError", and
                              "GeneralThresholdError".
                            "type": "str"  # Optional. type of alert. Known values are:
                              "Budget", "Invoice", "Credit", "Quota", "General", "xCloud", and
                              "BudgetForecast".
                        },
                        "description": "str",  # Optional. Alert description.
                        "details": {
                            "amount": 0.0,  # Optional. budget threshold amount.
                            "companyName": "str",  # Optional. company name.
                            "contactEmails": [
                                "str"  # Optional. list of emails to contact.
                            ],
                            "contactGroups": [
                                "str"  # Optional. list of action groups to broadcast
                                  to.
                            ],
                            "contactRoles": [
                                "str"  # Optional. list of contact roles.
                            ],
                            "currentSpend": 0.0,  # Optional. current spend.
                            "departmentName": "str",  # Optional. department name.
                            "enrollmentEndDate": "str",  # Optional. datetime of
                              enrollmentEndDate.
                            "enrollmentNumber": "str",  # Optional. enrollment number.
                            "enrollmentStartDate": "str",  # Optional. datetime of
                              enrollmentStartDate.
                            "invoicingThreshold": 0.0,  # Optional. invoicing threshold.
                            "meterFilter": [
                                {}  # Optional. array of meters to filter by.
                            ],
                            "operator": "str",  # Optional. operator used to compare
                              currentSpend with amount. Known values are: "None", "EqualTo",
                              "GreaterThan", "GreaterThanOrEqualTo", "LessThan", and
                              "LessThanOrEqualTo".
                            "overridingAlert": "str",  # Optional. overriding alert.
                            "periodStartDate": "str",  # Optional. datetime of
                              periodStartDate.
                            "resourceFilter": [
                                {}  # Optional. array of resources to filter by.
                            ],
                            "resourceGroupFilter": [
                                {}  # Optional. array of resourceGroups to filter by.
                            ],
                            "tagFilter": {},  # Optional. tags to filter by.
                            "threshold": 0.0,  # Optional. notification threshold
                              percentage as a decimal which activated this alert.
                            "timeGrainType": "str",  # Optional. Type of timegrain
                              cadence. Known values are: "None", "Monthly", "Quarterly", "Annually",
                              "BillingMonth", "BillingQuarter", and "BillingAnnual".
                            "triggeredBy": "str",  # Optional. notificationId that
                              triggered this alert.
                            "unit": "str"  # Optional. unit of currency being used.
                        },
                        "modificationTime": "str",  # Optional. dateTime in which alert was
                          last modified.
                        "source": "str",  # Optional. Source of alert. Known values are:
                          "Preset" and "User".
                        "status": "str",  # Optional. alert status. Known values are: "None",
                          "Active", "Overridden", "Resolved", and "Dismissed".
                        "statusModificationTime": "str",  # Optional. dateTime in which the
                          alert status was last modified.
                        "statusModificationUserName": "str"  # Optional. User who last
                          modified the alert.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """

    @overload
    def dismiss(
        self, scope: str, alert_id: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Dismisses the specified alert.

        :param scope: The scope associated with alerts operations. This includes
         '/subscriptions/{subscriptionId}/' for subscription scope,
         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
         for Department scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
         for EnrollmentAccount scope,
         '/providers/Microsoft.Management/managementGroups/{managementGroupId} for Management Group
         scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
         for billingProfile scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
         for invoiceSection scope, and
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}'
         specific for partners. Required.
        :type scope: str
        :param alert_id: Alert ID. Required.
        :type alert_id: str
        :param parameters: Parameters supplied to the Dismiss Alert operation. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "eTag": "str",  # Optional. eTag of the resource. To handle concurrent update
                      scenario, this field will be used to determine whether the user is updating the
                      latest version or not.
                    "id": "str",  # Optional. Resource Id.
                    "name": "str",  # Optional. Resource name.
                    "properties": {
                        "closeTime": "str",  # Optional. dateTime in which alert was closed.
                        "costEntityId": "str",  # Optional. related budget.
                        "creationTime": "str",  # Optional. dateTime in which alert was
                          created.
                        "definition": {
                            "category": "str",  # Optional. Alert category. Known values
                              are: "Cost", "Usage", "Billing", and "System".
                            "criteria": "str",  # Optional. Criteria that triggered
                              alert. Known values are: "CostThresholdExceeded",
                              "UsageThresholdExceeded", "CreditThresholdApproaching",
                              "CreditThresholdReached", "QuotaThresholdApproaching",
                              "QuotaThresholdReached", "MultiCurrency",
                              "ForecastCostThresholdExceeded", "ForecastUsageThresholdExceeded",
                              "InvoiceDueDateApproaching", "InvoiceDueDateReached",
                              "CrossCloudNewDataAvailable", "CrossCloudCollectionError", and
                              "GeneralThresholdError".
                            "type": "str"  # Optional. type of alert. Known values are:
                              "Budget", "Invoice", "Credit", "Quota", "General", "xCloud", and
                              "BudgetForecast".
                        },
                        "description": "str",  # Optional. Alert description.
                        "details": {
                            "amount": 0.0,  # Optional. budget threshold amount.
                            "companyName": "str",  # Optional. company name.
                            "contactEmails": [
                                "str"  # Optional. list of emails to contact.
                            ],
                            "contactGroups": [
                                "str"  # Optional. list of action groups to broadcast
                                  to.
                            ],
                            "contactRoles": [
                                "str"  # Optional. list of contact roles.
                            ],
                            "currentSpend": 0.0,  # Optional. current spend.
                            "departmentName": "str",  # Optional. department name.
                            "enrollmentEndDate": "str",  # Optional. datetime of
                              enrollmentEndDate.
                            "enrollmentNumber": "str",  # Optional. enrollment number.
                            "enrollmentStartDate": "str",  # Optional. datetime of
                              enrollmentStartDate.
                            "invoicingThreshold": 0.0,  # Optional. invoicing threshold.
                            "meterFilter": [
                                {}  # Optional. array of meters to filter by.
                            ],
                            "operator": "str",  # Optional. operator used to compare
                              currentSpend with amount. Known values are: "None", "EqualTo",
                              "GreaterThan", "GreaterThanOrEqualTo", "LessThan", and
                              "LessThanOrEqualTo".
                            "overridingAlert": "str",  # Optional. overriding alert.
                            "periodStartDate": "str",  # Optional. datetime of
                              periodStartDate.
                            "resourceFilter": [
                                {}  # Optional. array of resources to filter by.
                            ],
                            "resourceGroupFilter": [
                                {}  # Optional. array of resourceGroups to filter by.
                            ],
                            "tagFilter": {},  # Optional. tags to filter by.
                            "threshold": 0.0,  # Optional. notification threshold
                              percentage as a decimal which activated this alert.
                            "timeGrainType": "str",  # Optional. Type of timegrain
                              cadence. Known values are: "None", "Monthly", "Quarterly", "Annually",
                              "BillingMonth", "BillingQuarter", and "BillingAnnual".
                            "triggeredBy": "str",  # Optional. notificationId that
                              triggered this alert.
                            "unit": "str"  # Optional. unit of currency being used.
                        },
                        "modificationTime": "str",  # Optional. dateTime in which alert was
                          last modified.
                        "source": "str",  # Optional. Source of alert. Known values are:
                          "Preset" and "User".
                        "status": "str",  # Optional. alert status. Known values are: "None",
                          "Active", "Overridden", "Resolved", and "Dismissed".
                        "statusModificationTime": "str",  # Optional. dateTime in which the
                          alert status was last modified.
                        "statusModificationUserName": "str"  # Optional. User who last
                          modified the alert.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """

    @distributed_trace
    def dismiss(self, scope: str, alert_id: str, parameters: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Dismisses the specified alert.

        :param scope: The scope associated with alerts operations. This includes
         '/subscriptions/{subscriptionId}/' for subscription scope,
         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
         for Department scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
         for EnrollmentAccount scope,
         '/providers/Microsoft.Management/managementGroups/{managementGroupId} for Management Group
         scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
         for billingProfile scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
         for invoiceSection scope, and
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}'
         specific for partners. Required.
        :type scope: str
        :param alert_id: Alert ID. Required.
        :type alert_id: str
        :param parameters: Parameters supplied to the Dismiss Alert operation. Is either a model type
         or a IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "eTag": "str",  # Optional. eTag of the resource. To handle concurrent update
                      scenario, this field will be used to determine whether the user is updating the
                      latest version or not.
                    "id": "str",  # Optional. Resource Id.
                    "name": "str",  # Optional. Resource name.
                    "properties": {
                        "closeTime": "str",  # Optional. dateTime in which alert was closed.
                        "costEntityId": "str",  # Optional. related budget.
                        "creationTime": "str",  # Optional. dateTime in which alert was
                          created.
                        "definition": {
                            "category": "str",  # Optional. Alert category. Known values
                              are: "Cost", "Usage", "Billing", and "System".
                            "criteria": "str",  # Optional. Criteria that triggered
                              alert. Known values are: "CostThresholdExceeded",
                              "UsageThresholdExceeded", "CreditThresholdApproaching",
                              "CreditThresholdReached", "QuotaThresholdApproaching",
                              "QuotaThresholdReached", "MultiCurrency",
                              "ForecastCostThresholdExceeded", "ForecastUsageThresholdExceeded",
                              "InvoiceDueDateApproaching", "InvoiceDueDateReached",
                              "CrossCloudNewDataAvailable", "CrossCloudCollectionError", and
                              "GeneralThresholdError".
                            "type": "str"  # Optional. type of alert. Known values are:
                              "Budget", "Invoice", "Credit", "Quota", "General", "xCloud", and
                              "BudgetForecast".
                        },
                        "description": "str",  # Optional. Alert description.
                        "details": {
                            "amount": 0.0,  # Optional. budget threshold amount.
                            "companyName": "str",  # Optional. company name.
                            "contactEmails": [
                                "str"  # Optional. list of emails to contact.
                            ],
                            "contactGroups": [
                                "str"  # Optional. list of action groups to broadcast
                                  to.
                            ],
                            "contactRoles": [
                                "str"  # Optional. list of contact roles.
                            ],
                            "currentSpend": 0.0,  # Optional. current spend.
                            "departmentName": "str",  # Optional. department name.
                            "enrollmentEndDate": "str",  # Optional. datetime of
                              enrollmentEndDate.
                            "enrollmentNumber": "str",  # Optional. enrollment number.
                            "enrollmentStartDate": "str",  # Optional. datetime of
                              enrollmentStartDate.
                            "invoicingThreshold": 0.0,  # Optional. invoicing threshold.
                            "meterFilter": [
                                {}  # Optional. array of meters to filter by.
                            ],
                            "operator": "str",  # Optional. operator used to compare
                              currentSpend with amount. Known values are: "None", "EqualTo",
                              "GreaterThan", "GreaterThanOrEqualTo", "LessThan", and
                              "LessThanOrEqualTo".
                            "overridingAlert": "str",  # Optional. overriding alert.
                            "periodStartDate": "str",  # Optional. datetime of
                              periodStartDate.
                            "resourceFilter": [
                                {}  # Optional. array of resources to filter by.
                            ],
                            "resourceGroupFilter": [
                                {}  # Optional. array of resourceGroups to filter by.
                            ],
                            "tagFilter": {},  # Optional. tags to filter by.
                            "threshold": 0.0,  # Optional. notification threshold
                              percentage as a decimal which activated this alert.
                            "timeGrainType": "str",  # Optional. Type of timegrain
                              cadence. Known values are: "None", "Monthly", "Quarterly", "Annually",
                              "BillingMonth", "BillingQuarter", and "BillingAnnual".
                            "triggeredBy": "str",  # Optional. notificationId that
                              triggered this alert.
                            "unit": "str"  # Optional. unit of currency being used.
                        },
                        "modificationTime": "str",  # Optional. dateTime in which alert was
                          last modified.
                        "source": "str",  # Optional. Source of alert. Known values are:
                          "Preset" and "User".
                        "status": "str",  # Optional. alert status. Known values are: "None",
                          "Active", "Overridden", "Resolved", and "Dismissed".
                        "statusModificationTime": "str",  # Optional. dateTime in which the
                          alert status was last modified.
                        "statusModificationUserName": "str"  # Optional. User who last
                          modified the alert.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IO, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_alerts_dismiss_request(
            scope=scope,
            alert_id=alert_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def list_external(self, external_cloud_provider_type: str, external_cloud_provider_id: str, **kwargs: Any) -> JSON:
        """Lists the Alerts for external cloud provider type defined.

        :param external_cloud_provider_type: The external cloud provider type associated with
         dimension/query operations. This includes 'externalSubscriptions' for linked account and
         'externalBillingAccounts' for consolidated account. Known values are: "externalSubscriptions"
         and "externalBillingAccounts". Required.
        :type external_cloud_provider_type: str
        :param external_cloud_provider_id: This can be '{externalSubscriptionId}' for linked account or
         '{externalBillingAccountId}' for consolidated account used with dimension/query operations.
         Required.
        :type external_cloud_provider_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "nextLink": "str",  # Optional. URL to get the next set of alerts results if
                      there are any.
                    "value": [
                        {
                            "eTag": "str",  # Optional. eTag of the resource. To handle
                              concurrent update scenario, this field will be used to determine whether
                              the user is updating the latest version or not.
                            "id": "str",  # Optional. Resource Id.
                            "name": "str",  # Optional. Resource name.
                            "properties": {
                                "closeTime": "str",  # Optional. dateTime in which
                                  alert was closed.
                                "costEntityId": "str",  # Optional. related budget.
                                "creationTime": "str",  # Optional. dateTime in which
                                  alert was created.
                                "definition": {
                                    "category": "str",  # Optional. Alert
                                      category. Known values are: "Cost", "Usage", "Billing", and
                                      "System".
                                    "criteria": "str",  # Optional. Criteria that
                                      triggered alert. Known values are: "CostThresholdExceeded",
                                      "UsageThresholdExceeded", "CreditThresholdApproaching",
                                      "CreditThresholdReached", "QuotaThresholdApproaching",
                                      "QuotaThresholdReached", "MultiCurrency",
                                      "ForecastCostThresholdExceeded",
                                      "ForecastUsageThresholdExceeded", "InvoiceDueDateApproaching",
                                      "InvoiceDueDateReached", "CrossCloudNewDataAvailable",
                                      "CrossCloudCollectionError", and "GeneralThresholdError".
                                    "type": "str"  # Optional. type of alert.
                                      Known values are: "Budget", "Invoice", "Credit", "Quota",
                                      "General", "xCloud", and "BudgetForecast".
                                },
                                "description": "str",  # Optional. Alert description.
                                "details": {
                                    "amount": 0.0,  # Optional. budget threshold
                                      amount.
                                    "companyName": "str",  # Optional. company
                                      name.
                                    "contactEmails": [
                                        "str"  # Optional. list of emails to
                                          contact.
                                    ],
                                    "contactGroups": [
                                        "str"  # Optional. list of action
                                          groups to broadcast to.
                                    ],
                                    "contactRoles": [
                                        "str"  # Optional. list of contact
                                          roles.
                                    ],
                                    "currentSpend": 0.0,  # Optional. current
                                      spend.
                                    "departmentName": "str",  # Optional.
                                      department name.
                                    "enrollmentEndDate": "str",  # Optional.
                                      datetime of enrollmentEndDate.
                                    "enrollmentNumber": "str",  # Optional.
                                      enrollment number.
                                    "enrollmentStartDate": "str",  # Optional.
                                      datetime of enrollmentStartDate.
                                    "invoicingThreshold": 0.0,  # Optional.
                                      invoicing threshold.
                                    "meterFilter": [
                                        {}  # Optional. array of meters to
                                          filter by.
                                    ],
                                    "operator": "str",  # Optional. operator used
                                      to compare currentSpend with amount. Known values are: "None",
                                      "EqualTo", "GreaterThan", "GreaterThanOrEqualTo", "LessThan", and
                                      "LessThanOrEqualTo".
                                    "overridingAlert": "str",  # Optional.
                                      overriding alert.
                                    "periodStartDate": "str",  # Optional.
                                      datetime of periodStartDate.
                                    "resourceFilter": [
                                        {}  # Optional. array of resources to
                                          filter by.
                                    ],
                                    "resourceGroupFilter": [
                                        {}  # Optional. array of
                                          resourceGroups to filter by.
                                    ],
                                    "tagFilter": {},  # Optional. tags to filter
                                      by.
                                    "threshold": 0.0,  # Optional. notification
                                      threshold percentage as a decimal which activated this alert.
                                    "timeGrainType": "str",  # Optional. Type of
                                      timegrain cadence. Known values are: "None", "Monthly",
                                      "Quarterly", "Annually", "BillingMonth", "BillingQuarter", and
                                      "BillingAnnual".
                                    "triggeredBy": "str",  # Optional.
                                      notificationId that triggered this alert.
                                    "unit": "str"  # Optional. unit of currency
                                      being used.
                                },
                                "modificationTime": "str",  # Optional. dateTime in
                                  which alert was last modified.
                                "source": "str",  # Optional. Source of alert. Known
                                  values are: "Preset" and "User".
                                "status": "str",  # Optional. alert status. Known
                                  values are: "None", "Active", "Overridden", "Resolved", and
                                  "Dismissed".
                                "statusModificationTime": "str",  # Optional.
                                  dateTime in which the alert status was last modified.
                                "statusModificationUserName": "str"  # Optional. User
                                  who last modified the alert.
                            },
                            "type": "str"  # Optional. Resource type.
                        }
                    ]
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_alerts_list_external_request(
            external_cloud_provider_type=external_cloud_provider_type,
            external_cloud_provider_id=external_cloud_provider_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class ForecastOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.costmanagement.CostManagementClient`'s
        :attr:`forecast` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def usage(
        self,
        scope: str,
        parameters: JSON,
        *,
        filter: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Optional[JSON]:
        """Lists the forecast charges for scope defined.

        :param scope: The scope associated with forecast operations. This includes
         '/subscriptions/{subscriptionId}/' for subscription scope,
         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
         for Department scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
         for EnrollmentAccount scope,
         '/providers/Microsoft.Management/managementGroups/{managementGroupId} for Management Group
         scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
         for billingProfile scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
         for invoiceSection scope, and
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}'
         specific for partners. Required.
        :type scope: str
        :param parameters: Parameters supplied to the CreateOrUpdate Forecast Config operation.
         Required.
        :type parameters: JSON
        :keyword filter: May be used to filter forecasts by properties/usageDate (Utc time),
         properties/chargeType or properties/grain. The filter supports 'eq', 'lt', 'gt', 'le', 'ge',
         and 'and'. It does not currently support 'ne', 'or', or 'not'. Default value is None.
        :paramtype filter: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "dataset": {
                        "aggregation": {
                            "str": {
                                "function": "str",  # The name of the aggregation
                                  function to use. Required. "Sum"
                                "name": "str"  # The name of the column to aggregate.
                                  Required.
                            }
                        },
                        "configuration": {
                            "columns": [
                                "str"  # Optional. Array of column names to be
                                  included in the query. Any valid query column name is allowed. If not
                                  provided, then query includes all columns.
                            ]
                        },
                        "filter": {
                            "and": [
                                ...
                            ],
                            "dimensions": {
                                "name": "str",  # The name of the column to use in
                                  comparison. Required.
                                "operator": "str",  # The operator to use for
                                  comparison. Required. "In"
                                "values": [
                                    "str"  # Array of values to use for
                                      comparison. Required.
                                ]
                            },
                            "or": [
                                ...
                            ],
                            "tags": {
                                "name": "str",  # The name of the column to use in
                                  comparison. Required.
                                "operator": "str",  # The operator to use for
                                  comparison. Required. "In"
                                "values": [
                                    "str"  # Array of values to use for
                                      comparison. Required.
                                ]
                            }
                        },
                        "granularity": "str"  # Optional. The granularity of rows in the
                          forecast. "Daily"
                    },
                    "includeActualCost": bool,  # Optional. a boolean determining if actualCost
                      will be included.
                    "includeFreshPartialCost": bool,  # Optional. a boolean determining if
                      FreshPartialCost will be included.
                    "timePeriod": {
                        "from": "2020-02-20 00:00:00",  # The start date to pull data from.
                          Required.
                        "to": "2020-02-20 00:00:00"  # The end date to pull data to.
                          Required.
                    },
                    "timeframe": "str",  # The time frame for pulling data for the forecast. If
                      custom, then a specific time period must be provided. Required. Known values are:
                      "MonthToDate", "BillingMonthToDate", "TheLastMonth", "TheLastBillingMonth",
                      "WeekToDate", and "Custom".
                    "type": "str"  # The type of the forecast. Required. Known values are:
                      "Usage", "ActualCost", and "AmortizedCost".
                }

                # response body for status code(s): 200
                response == {
                    "eTag": "str",  # Optional. ETag of the resource.
                    "id": "str",  # Optional. Resource Id.
                    "location": "str",  # Optional. Location of the resource.
                    "name": "str",  # Optional. Resource name.
                    "properties": {
                        "columns": [
                            {
                                "name": "str",  # Optional. The name of column.
                                "type": "str"  # Optional. The type of column.
                            }
                        ],
                        "nextLink": "str",  # Optional. The link (url) to the next page of
                          results.
                        "rows": [
                            [
                                {}  # Optional. Array of rows.
                            ]
                        ]
                    },
                    "sku": "str",  # Optional. SKU of the resource.
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """

    @overload
    def usage(
        self,
        scope: str,
        parameters: IO,
        *,
        filter: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Optional[JSON]:
        """Lists the forecast charges for scope defined.

        :param scope: The scope associated with forecast operations. This includes
         '/subscriptions/{subscriptionId}/' for subscription scope,
         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
         for Department scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
         for EnrollmentAccount scope,
         '/providers/Microsoft.Management/managementGroups/{managementGroupId} for Management Group
         scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
         for billingProfile scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
         for invoiceSection scope, and
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}'
         specific for partners. Required.
        :type scope: str
        :param parameters: Parameters supplied to the CreateOrUpdate Forecast Config operation.
         Required.
        :type parameters: IO
        :keyword filter: May be used to filter forecasts by properties/usageDate (Utc time),
         properties/chargeType or properties/grain. The filter supports 'eq', 'lt', 'gt', 'le', 'ge',
         and 'and'. It does not currently support 'ne', 'or', or 'not'. Default value is None.
        :paramtype filter: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "eTag": "str",  # Optional. ETag of the resource.
                    "id": "str",  # Optional. Resource Id.
                    "location": "str",  # Optional. Location of the resource.
                    "name": "str",  # Optional. Resource name.
                    "properties": {
                        "columns": [
                            {
                                "name": "str",  # Optional. The name of column.
                                "type": "str"  # Optional. The type of column.
                            }
                        ],
                        "nextLink": "str",  # Optional. The link (url) to the next page of
                          results.
                        "rows": [
                            [
                                {}  # Optional. Array of rows.
                            ]
                        ]
                    },
                    "sku": "str",  # Optional. SKU of the resource.
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """

    @distributed_trace
    def usage(
        self, scope: str, parameters: Union[JSON, IO], *, filter: Optional[str] = None, **kwargs: Any
    ) -> Optional[JSON]:
        """Lists the forecast charges for scope defined.

        :param scope: The scope associated with forecast operations. This includes
         '/subscriptions/{subscriptionId}/' for subscription scope,
         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
         for Department scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
         for EnrollmentAccount scope,
         '/providers/Microsoft.Management/managementGroups/{managementGroupId} for Management Group
         scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
         for billingProfile scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
         for invoiceSection scope, and
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}'
         specific for partners. Required.
        :type scope: str
        :param parameters: Parameters supplied to the CreateOrUpdate Forecast Config operation. Is
         either a model type or a IO type. Required.
        :type parameters: JSON or IO
        :keyword filter: May be used to filter forecasts by properties/usageDate (Utc time),
         properties/chargeType or properties/grain. The filter supports 'eq', 'lt', 'gt', 'le', 'ge',
         and 'and'. It does not currently support 'ne', 'or', or 'not'. Default value is None.
        :paramtype filter: str
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "eTag": "str",  # Optional. ETag of the resource.
                    "id": "str",  # Optional. Resource Id.
                    "location": "str",  # Optional. Location of the resource.
                    "name": "str",  # Optional. Resource name.
                    "properties": {
                        "columns": [
                            {
                                "name": "str",  # Optional. The name of column.
                                "type": "str"  # Optional. The type of column.
                            }
                        ],
                        "nextLink": "str",  # Optional. The link (url) to the next page of
                          results.
                        "rows": [
                            [
                                {}  # Optional. Array of rows.
                            ]
                        ]
                    },
                    "sku": "str",  # Optional. SKU of the resource.
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IO, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_forecast_usage_request(
            scope=scope,
            filter=filter,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def external_cloud_provider_usage(
        self,
        external_cloud_provider_type: str,
        external_cloud_provider_id: str,
        parameters: JSON,
        *,
        filter: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Lists the forecast charges for external cloud provider type defined.

        :param external_cloud_provider_type: The external cloud provider type associated with
         dimension/query operations. This includes 'externalSubscriptions' for linked account and
         'externalBillingAccounts' for consolidated account. Known values are: "externalSubscriptions"
         and "externalBillingAccounts". Required.
        :type external_cloud_provider_type: str
        :param external_cloud_provider_id: This can be '{externalSubscriptionId}' for linked account or
         '{externalBillingAccountId}' for consolidated account used with dimension/query operations.
         Required.
        :type external_cloud_provider_id: str
        :param parameters: Parameters supplied to the CreateOrUpdate Forecast Config operation.
         Required.
        :type parameters: JSON
        :keyword filter: May be used to filter forecasts by properties/usageDate (Utc time),
         properties/chargeType or properties/grain. The filter supports 'eq', 'lt', 'gt', 'le', 'ge',
         and 'and'. It does not currently support 'ne', 'or', or 'not'. Default value is None.
        :paramtype filter: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "dataset": {
                        "aggregation": {
                            "str": {
                                "function": "str",  # The name of the aggregation
                                  function to use. Required. "Sum"
                                "name": "str"  # The name of the column to aggregate.
                                  Required.
                            }
                        },
                        "configuration": {
                            "columns": [
                                "str"  # Optional. Array of column names to be
                                  included in the query. Any valid query column name is allowed. If not
                                  provided, then query includes all columns.
                            ]
                        },
                        "filter": {
                            "and": [
                                ...
                            ],
                            "dimensions": {
                                "name": "str",  # The name of the column to use in
                                  comparison. Required.
                                "operator": "str",  # The operator to use for
                                  comparison. Required. "In"
                                "values": [
                                    "str"  # Array of values to use for
                                      comparison. Required.
                                ]
                            },
                            "or": [
                                ...
                            ],
                            "tags": {
                                "name": "str",  # The name of the column to use in
                                  comparison. Required.
                                "operator": "str",  # The operator to use for
                                  comparison. Required. "In"
                                "values": [
                                    "str"  # Array of values to use for
                                      comparison. Required.
                                ]
                            }
                        },
                        "granularity": "str"  # Optional. The granularity of rows in the
                          forecast. "Daily"
                    },
                    "includeActualCost": bool,  # Optional. a boolean determining if actualCost
                      will be included.
                    "includeFreshPartialCost": bool,  # Optional. a boolean determining if
                      FreshPartialCost will be included.
                    "timePeriod": {
                        "from": "2020-02-20 00:00:00",  # The start date to pull data from.
                          Required.
                        "to": "2020-02-20 00:00:00"  # The end date to pull data to.
                          Required.
                    },
                    "timeframe": "str",  # The time frame for pulling data for the forecast. If
                      custom, then a specific time period must be provided. Required. Known values are:
                      "MonthToDate", "BillingMonthToDate", "TheLastMonth", "TheLastBillingMonth",
                      "WeekToDate", and "Custom".
                    "type": "str"  # The type of the forecast. Required. Known values are:
                      "Usage", "ActualCost", and "AmortizedCost".
                }

                # response body for status code(s): 200
                response == {
                    "eTag": "str",  # Optional. ETag of the resource.
                    "id": "str",  # Optional. Resource Id.
                    "location": "str",  # Optional. Location of the resource.
                    "name": "str",  # Optional. Resource name.
                    "properties": {
                        "columns": [
                            {
                                "name": "str",  # Optional. The name of column.
                                "type": "str"  # Optional. The type of column.
                            }
                        ],
                        "nextLink": "str",  # Optional. The link (url) to the next page of
                          results.
                        "rows": [
                            [
                                {}  # Optional. Array of rows.
                            ]
                        ]
                    },
                    "sku": "str",  # Optional. SKU of the resource.
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """

    @overload
    def external_cloud_provider_usage(
        self,
        external_cloud_provider_type: str,
        external_cloud_provider_id: str,
        parameters: IO,
        *,
        filter: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Lists the forecast charges for external cloud provider type defined.

        :param external_cloud_provider_type: The external cloud provider type associated with
         dimension/query operations. This includes 'externalSubscriptions' for linked account and
         'externalBillingAccounts' for consolidated account. Known values are: "externalSubscriptions"
         and "externalBillingAccounts". Required.
        :type external_cloud_provider_type: str
        :param external_cloud_provider_id: This can be '{externalSubscriptionId}' for linked account or
         '{externalBillingAccountId}' for consolidated account used with dimension/query operations.
         Required.
        :type external_cloud_provider_id: str
        :param parameters: Parameters supplied to the CreateOrUpdate Forecast Config operation.
         Required.
        :type parameters: IO
        :keyword filter: May be used to filter forecasts by properties/usageDate (Utc time),
         properties/chargeType or properties/grain. The filter supports 'eq', 'lt', 'gt', 'le', 'ge',
         and 'and'. It does not currently support 'ne', 'or', or 'not'. Default value is None.
        :paramtype filter: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "eTag": "str",  # Optional. ETag of the resource.
                    "id": "str",  # Optional. Resource Id.
                    "location": "str",  # Optional. Location of the resource.
                    "name": "str",  # Optional. Resource name.
                    "properties": {
                        "columns": [
                            {
                                "name": "str",  # Optional. The name of column.
                                "type": "str"  # Optional. The type of column.
                            }
                        ],
                        "nextLink": "str",  # Optional. The link (url) to the next page of
                          results.
                        "rows": [
                            [
                                {}  # Optional. Array of rows.
                            ]
                        ]
                    },
                    "sku": "str",  # Optional. SKU of the resource.
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """

    @distributed_trace
    def external_cloud_provider_usage(
        self,
        external_cloud_provider_type: str,
        external_cloud_provider_id: str,
        parameters: Union[JSON, IO],
        *,
        filter: Optional[str] = None,
        **kwargs: Any
    ) -> JSON:
        """Lists the forecast charges for external cloud provider type defined.

        :param external_cloud_provider_type: The external cloud provider type associated with
         dimension/query operations. This includes 'externalSubscriptions' for linked account and
         'externalBillingAccounts' for consolidated account. Known values are: "externalSubscriptions"
         and "externalBillingAccounts". Required.
        :type external_cloud_provider_type: str
        :param external_cloud_provider_id: This can be '{externalSubscriptionId}' for linked account or
         '{externalBillingAccountId}' for consolidated account used with dimension/query operations.
         Required.
        :type external_cloud_provider_id: str
        :param parameters: Parameters supplied to the CreateOrUpdate Forecast Config operation. Is
         either a model type or a IO type. Required.
        :type parameters: JSON or IO
        :keyword filter: May be used to filter forecasts by properties/usageDate (Utc time),
         properties/chargeType or properties/grain. The filter supports 'eq', 'lt', 'gt', 'le', 'ge',
         and 'and'. It does not currently support 'ne', 'or', or 'not'. Default value is None.
        :paramtype filter: str
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "eTag": "str",  # Optional. ETag of the resource.
                    "id": "str",  # Optional. Resource Id.
                    "location": "str",  # Optional. Location of the resource.
                    "name": "str",  # Optional. Resource name.
                    "properties": {
                        "columns": [
                            {
                                "name": "str",  # Optional. The name of column.
                                "type": "str"  # Optional. The type of column.
                            }
                        ],
                        "nextLink": "str",  # Optional. The link (url) to the next page of
                          results.
                        "rows": [
                            [
                                {}  # Optional. Array of rows.
                            ]
                        ]
                    },
                    "sku": "str",  # Optional. SKU of the resource.
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IO, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_forecast_external_cloud_provider_usage_request(
            external_cloud_provider_type=external_cloud_provider_type,
            external_cloud_provider_id=external_cloud_provider_id,
            filter=filter,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class DimensionsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.costmanagement.CostManagementClient`'s
        :attr:`dimensions` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        scope: str,
        *,
        filter: Optional[str] = None,
        expand: Optional[str] = None,
        skiptoken: Optional[str] = None,
        top: Optional[int] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Lists the dimensions by the defined scope.

        :param scope: The scope associated with dimension operations. This includes
         '/subscriptions/{subscriptionId}/' for subscription scope,
         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
         for Department scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
         for EnrollmentAccount scope,
         '/providers/Microsoft.Management/managementGroups/{managementGroupId}' for Management Group
         scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
         for billingProfile scope,
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
         for invoiceSection scope, and
         'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}'
         specific for partners. Required.
        :type scope: str
        :keyword filter: May be used to filter dimensions by properties/category,
         properties/usageStart, properties/usageEnd. Supported operators are 'eq','lt', 'gt', 'le',
         'ge'. Default value is None.
        :paramtype filter: str
        :keyword expand: May be used to expand the properties/data within a dimension category. By
         default, data is not included when listing dimensions. Default value is None.
        :paramtype expand: str
        :keyword skiptoken: Skiptoken is only used if a previous operation returned a partial result.
         If a previous response contains a nextLink element, the value of the nextLink element will
         include a skiptoken parameter that specifies a starting point to use for subsequent calls.
         Default value is None.
        :paramtype skiptoken: str
        :keyword top: May be used to limit the number of results to the most recent N dimension data.
         Default value is None.
        :paramtype top: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 204
                response == {
                    "eTag": "str",  # Optional. ETag of the resource.
                    "id": "str",  # Optional. Resource Id.
                    "location": "str",  # Optional. Location of the resource.
                    "name": "str",  # Optional. Resource name.
                    "properties": {
                        "category": "str",  # Optional. Dimension category.
                        "data": [
                            "str"  # Optional. Dimension data.
                        ],
                        "description": "str",  # Optional. Dimension description.
                        "filterEnabled": bool,  # Optional. Filter enabled.
                        "groupingEnabled": bool,  # Optional. Grouping enabled.
                        "nextLink": "str",  # Optional. The link (url) to the next page of
                          results.
                        "total": 0,  # Optional. Total number of data for the dimension.
                        "usageEnd": "2020-02-20 00:00:00",  # Optional. Usage end.
                        "usageStart": "2020-02-20 00:00:00"  # Optional. Usage start.
                    },
                    "sku": "str",  # Optional. SKU of the resource.
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_dimensions_list_request(
                    scope=scope,
                    filter=filter,
                    expand=expand,
                    skiptoken=skiptoken,
                    top=top,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200, 204]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def by_external_cloud_provider_type(
        self,
        external_cloud_provider_type: str,
        external_cloud_provider_id: str,
        *,
        filter: Optional[str] = None,
        expand: Optional[str] = None,
        skiptoken: Optional[str] = None,
        top: Optional[int] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Lists the dimensions by the external cloud provider type.

        :param external_cloud_provider_type: The external cloud provider type associated with
         dimension/query operations. This includes 'externalSubscriptions' for linked account and
         'externalBillingAccounts' for consolidated account. Known values are: "externalSubscriptions"
         and "externalBillingAccounts". Required.
        :type external_cloud_provider_type: str
        :param external_cloud_provider_id: This can be '{externalSubscriptionId}' for linked account or
         '{externalBillingAccountId}' for consolidated account used with dimension/query operations.
         Required.
        :type external_cloud_provider_id: str
        :keyword filter: May be used to filter dimensions by properties/category,
         properties/usageStart, properties/usageEnd. Supported operators are 'eq','lt', 'gt', 'le',
         'ge'. Default value is None.
        :paramtype filter: str
        :keyword expand: May be used to expand the properties/data within a dimension category. By
         default, data is not included when listing dimensions. Default value is None.
        :paramtype expand: str
        :keyword skiptoken: Skiptoken is only used if a previous operation returned a partial result.
         If a previous response contains a nextLink element, the value of the nextLink element will
         include a skiptoken parameter that specifies a starting point to use for subsequent calls.
         Default value is None.
        :paramtype skiptoken: str
        :keyword top: May be used to limit the number of results to the most recent N dimension data.
         Default value is None.
        :paramtype top: int
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "eTag": "str",  # Optional. ETag of the resource.
                    "id": "str",  # Optional. Resource Id.
                    "location": "str",  # Optional. Location of the resource.
                    "name": "str",  # Optional. Resource name.
                    "properties": {
                        "category": "str",  # Optional. Dimension category.
                        "data": [
                            "str"  # Optional. Dimension data.
                        ],
                        "description": "str",  # Optional. Dimension description.
                        "filterEnabled": bool,  # Optional. Filter enabled.
                        "groupingEnabled": bool,  # Optional. Grouping enabled.
                        "nextLink": "str",  # Optional. The link (url) to the next page of
                          results.
                        "total": 0,  # Optional. Total number of data for the dimension.
                        "usageEnd": "2020-02-20 00:00:00",  # Optional. Usage end.
                        "usageStart": "2020-02-20 00:00:00"  # Optional. Usage start.
                    },
                    "sku": "str",  # Optional. SKU of the resource.
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_dimensions_by_external_cloud_provider_type_request(
                    external_cloud_provider_type=external_cloud_provider_type,
                    external_cloud_provider_id=external_cloud_provider_id,
                    filter=filter,
                    expand=expand,
                    skiptoken=skiptoken,
                    top=top,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)


class QueryOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.costmanagement.CostManagementClient`'s
        :attr:`query` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def usage(
        self, scope: str, parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Optional[JSON]:
        """Query the usage data for scope defined.

        :param scope: The scope associated with query and export operations. This includes
         '/subscriptions/{subscriptionId}/' for subscription scope,
         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
         for Department scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
         for EnrollmentAccount scope,
         '/providers/Microsoft.Management/managementGroups/{managementGroupId} for Management Group
         scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
         for billingProfile scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
         for invoiceSection scope, and
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}'
         specific for partners. Required.
        :type scope: str
        :param parameters: Parameters supplied to the CreateOrUpdate Query Config operation. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "dataset": {
                        "aggregation": {
                            "str": {
                                "function": "str",  # The name of the aggregation
                                  function to use. Required. "Sum"
                                "name": "str"  # The name of the column to aggregate.
                                  Required.
                            }
                        },
                        "configuration": {
                            "columns": [
                                "str"  # Optional. Array of column names to be
                                  included in the query. Any valid query column name is allowed. If not
                                  provided, then query includes all columns.
                            ]
                        },
                        "filter": {
                            "and": [
                                ...
                            ],
                            "dimensions": {
                                "name": "str",  # The name of the column to use in
                                  comparison. Required.
                                "operator": "str",  # The operator to use for
                                  comparison. Required. "In"
                                "values": [
                                    "str"  # Array of values to use for
                                      comparison. Required.
                                ]
                            },
                            "or": [
                                ...
                            ],
                            "tags": {
                                "name": "str",  # The name of the column to use in
                                  comparison. Required.
                                "operator": "str",  # The operator to use for
                                  comparison. Required. "In"
                                "values": [
                                    "str"  # Array of values to use for
                                      comparison. Required.
                                ]
                            }
                        },
                        "granularity": "str",  # Optional. The granularity of rows in the
                          query. "Daily"
                        "grouping": [
                            {
                                "name": "str",  # The name of the column to group.
                                  Required.
                                "type": "str"  # Has type of the column to group.
                                  Required. Known values are: "Tag" and "Dimension".
                            }
                        ]
                    },
                    "timePeriod": {
                        "from": "2020-02-20 00:00:00",  # The start date to pull data from.
                          Required.
                        "to": "2020-02-20 00:00:00"  # The end date to pull data to.
                          Required.
                    },
                    "timeframe": "str",  # The time frame for pulling data for the query. If
                      custom, then a specific time period must be provided. Required. Known values are:
                      "MonthToDate", "BillingMonthToDate", "TheLastMonth", "TheLastBillingMonth",
                      "WeekToDate", and "Custom".
                    "type": "str"  # The type of the query. Required. Known values are: "Usage",
                      "ActualCost", and "AmortizedCost".
                }

                # response body for status code(s): 200
                response == {
                    "eTag": "str",  # Optional. ETag of the resource.
                    "id": "str",  # Optional. Resource Id.
                    "location": "str",  # Optional. Location of the resource.
                    "name": "str",  # Optional. Resource name.
                    "properties": {
                        "columns": [
                            {
                                "name": "str",  # Optional. The name of column.
                                "type": "str"  # Optional. The type of column.
                            }
                        ],
                        "nextLink": "str",  # Optional. The link (url) to the next page of
                          results.
                        "rows": [
                            [
                                {}  # Optional. Array of rows.
                            ]
                        ]
                    },
                    "sku": "str",  # Optional. SKU of the resource.
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """

    @overload
    def usage(
        self, scope: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> Optional[JSON]:
        """Query the usage data for scope defined.

        :param scope: The scope associated with query and export operations. This includes
         '/subscriptions/{subscriptionId}/' for subscription scope,
         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
         for Department scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
         for EnrollmentAccount scope,
         '/providers/Microsoft.Management/managementGroups/{managementGroupId} for Management Group
         scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
         for billingProfile scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
         for invoiceSection scope, and
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}'
         specific for partners. Required.
        :type scope: str
        :param parameters: Parameters supplied to the CreateOrUpdate Query Config operation. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "eTag": "str",  # Optional. ETag of the resource.
                    "id": "str",  # Optional. Resource Id.
                    "location": "str",  # Optional. Location of the resource.
                    "name": "str",  # Optional. Resource name.
                    "properties": {
                        "columns": [
                            {
                                "name": "str",  # Optional. The name of column.
                                "type": "str"  # Optional. The type of column.
                            }
                        ],
                        "nextLink": "str",  # Optional. The link (url) to the next page of
                          results.
                        "rows": [
                            [
                                {}  # Optional. Array of rows.
                            ]
                        ]
                    },
                    "sku": "str",  # Optional. SKU of the resource.
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """

    @distributed_trace
    def usage(self, scope: str, parameters: Union[JSON, IO], **kwargs: Any) -> Optional[JSON]:
        """Query the usage data for scope defined.

        :param scope: The scope associated with query and export operations. This includes
         '/subscriptions/{subscriptionId}/' for subscription scope,
         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for resourceGroup scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for Billing Account scope and
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
         for Department scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
         for EnrollmentAccount scope,
         '/providers/Microsoft.Management/managementGroups/{managementGroupId} for Management Group
         scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
         for billingProfile scope,
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}/invoiceSections/{invoiceSectionId}'
         for invoiceSection scope, and
         '/providers/Microsoft.Billing/billingAccounts/{billingAccountId}/customers/{customerId}'
         specific for partners. Required.
        :type scope: str
        :param parameters: Parameters supplied to the CreateOrUpdate Query Config operation. Is either
         a model type or a IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "eTag": "str",  # Optional. ETag of the resource.
                    "id": "str",  # Optional. Resource Id.
                    "location": "str",  # Optional. Location of the resource.
                    "name": "str",  # Optional. Resource name.
                    "properties": {
                        "columns": [
                            {
                                "name": "str",  # Optional. The name of column.
                                "type": "str"  # Optional. The type of column.
                            }
                        ],
                        "nextLink": "str",  # Optional. The link (url) to the next page of
                          results.
                        "rows": [
                            [
                                {}  # Optional. Array of rows.
                            ]
                        ]
                    },
                    "sku": "str",  # Optional. SKU of the resource.
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IO, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_query_usage_request(
            scope=scope,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def usage_by_external_cloud_provider_type(
        self,
        external_cloud_provider_type: str,
        external_cloud_provider_id: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Query the usage data for external cloud provider type defined.

        :param external_cloud_provider_type: The external cloud provider type associated with
         dimension/query operations. This includes 'externalSubscriptions' for linked account and
         'externalBillingAccounts' for consolidated account. Known values are: "externalSubscriptions"
         and "externalBillingAccounts". Required.
        :type external_cloud_provider_type: str
        :param external_cloud_provider_id: This can be '{externalSubscriptionId}' for linked account or
         '{externalBillingAccountId}' for consolidated account used with dimension/query operations.
         Required.
        :type external_cloud_provider_id: str
        :param parameters: Parameters supplied to the CreateOrUpdate Query Config operation. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                parameters = {
                    "dataset": {
                        "aggregation": {
                            "str": {
                                "function": "str",  # The name of the aggregation
                                  function to use. Required. "Sum"
                                "name": "str"  # The name of the column to aggregate.
                                  Required.
                            }
                        },
                        "configuration": {
                            "columns": [
                                "str"  # Optional. Array of column names to be
                                  included in the query. Any valid query column name is allowed. If not
                                  provided, then query includes all columns.
                            ]
                        },
                        "filter": {
                            "and": [
                                ...
                            ],
                            "dimensions": {
                                "name": "str",  # The name of the column to use in
                                  comparison. Required.
                                "operator": "str",  # The operator to use for
                                  comparison. Required. "In"
                                "values": [
                                    "str"  # Array of values to use for
                                      comparison. Required.
                                ]
                            },
                            "or": [
                                ...
                            ],
                            "tags": {
                                "name": "str",  # The name of the column to use in
                                  comparison. Required.
                                "operator": "str",  # The operator to use for
                                  comparison. Required. "In"
                                "values": [
                                    "str"  # Array of values to use for
                                      comparison. Required.
                                ]
                            }
                        },
                        "granularity": "str",  # Optional. The granularity of rows in the
                          query. "Daily"
                        "grouping": [
                            {
                                "name": "str",  # The name of the column to group.
                                  Required.
                                "type": "str"  # Has type of the column to group.
                                  Required. Known values are: "Tag" and "Dimension".
                            }
                        ]
                    },
                    "timePeriod": {
                        "from": "2020-02-20 00:00:00",  # The start date to pull data from.
                          Required.
                        "to": "2020-02-20 00:00:00"  # The end date to pull data to.
                          Required.
                    },
                    "timeframe": "str",  # The time frame for pulling data for the query. If
                      custom, then a specific time period must be provided. Required. Known values are:
                      "MonthToDate", "BillingMonthToDate", "TheLastMonth", "TheLastBillingMonth",
                      "WeekToDate", and "Custom".
                    "type": "str"  # The type of the query. Required. Known values are: "Usage",
                      "ActualCost", and "AmortizedCost".
                }

                # response body for status code(s): 200
                response == {
                    "eTag": "str",  # Optional. ETag of the resource.
                    "id": "str",  # Optional. Resource Id.
                    "location": "str",  # Optional. Location of the resource.
                    "name": "str",  # Optional. Resource name.
                    "properties": {
                        "columns": [
                            {
                                "name": "str",  # Optional. The name of column.
                                "type": "str"  # Optional. The type of column.
                            }
                        ],
                        "nextLink": "str",  # Optional. The link (url) to the next page of
                          results.
                        "rows": [
                            [
                                {}  # Optional. Array of rows.
                            ]
                        ]
                    },
                    "sku": "str",  # Optional. SKU of the resource.
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """

    @overload
    def usage_by_external_cloud_provider_type(
        self,
        external_cloud_provider_type: str,
        external_cloud_provider_id: str,
        parameters: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Query the usage data for external cloud provider type defined.

        :param external_cloud_provider_type: The external cloud provider type associated with
         dimension/query operations. This includes 'externalSubscriptions' for linked account and
         'externalBillingAccounts' for consolidated account. Known values are: "externalSubscriptions"
         and "externalBillingAccounts". Required.
        :type external_cloud_provider_type: str
        :param external_cloud_provider_id: This can be '{externalSubscriptionId}' for linked account or
         '{externalBillingAccountId}' for consolidated account used with dimension/query operations.
         Required.
        :type external_cloud_provider_id: str
        :param parameters: Parameters supplied to the CreateOrUpdate Query Config operation. Required.
        :type parameters: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "eTag": "str",  # Optional. ETag of the resource.
                    "id": "str",  # Optional. Resource Id.
                    "location": "str",  # Optional. Location of the resource.
                    "name": "str",  # Optional. Resource name.
                    "properties": {
                        "columns": [
                            {
                                "name": "str",  # Optional. The name of column.
                                "type": "str"  # Optional. The type of column.
                            }
                        ],
                        "nextLink": "str",  # Optional. The link (url) to the next page of
                          results.
                        "rows": [
                            [
                                {}  # Optional. Array of rows.
                            ]
                        ]
                    },
                    "sku": "str",  # Optional. SKU of the resource.
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """

    @distributed_trace
    def usage_by_external_cloud_provider_type(
        self,
        external_cloud_provider_type: str,
        external_cloud_provider_id: str,
        parameters: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        """Query the usage data for external cloud provider type defined.

        :param external_cloud_provider_type: The external cloud provider type associated with
         dimension/query operations. This includes 'externalSubscriptions' for linked account and
         'externalBillingAccounts' for consolidated account. Known values are: "externalSubscriptions"
         and "externalBillingAccounts". Required.
        :type external_cloud_provider_type: str
        :param external_cloud_provider_id: This can be '{externalSubscriptionId}' for linked account or
         '{externalBillingAccountId}' for consolidated account used with dimension/query operations.
         Required.
        :type external_cloud_provider_id: str
        :param parameters: Parameters supplied to the CreateOrUpdate Query Config operation. Is either
         a model type or a IO type. Required.
        :type parameters: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "eTag": "str",  # Optional. ETag of the resource.
                    "id": "str",  # Optional. Resource Id.
                    "location": "str",  # Optional. Location of the resource.
                    "name": "str",  # Optional. Resource name.
                    "properties": {
                        "columns": [
                            {
                                "name": "str",  # Optional. The name of column.
                                "type": "str"  # Optional. The type of column.
                            }
                        ],
                        "nextLink": "str",  # Optional. The link (url) to the next page of
                          results.
                        "rows": [
                            [
                                {}  # Optional. Array of rows.
                            ]
                        ]
                    },
                    "sku": "str",  # Optional. SKU of the resource.
                    "tags": {
                        "str": "str"  # Optional. Resource tags.
                    },
                    "type": "str"  # Optional. Resource type.
                }
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(parameters, (IO, bytes)):
            _content = parameters
        else:
            _json = parameters

        request = build_query_usage_by_external_cloud_provider_type_request(
            external_cloud_provider_type=external_cloud_provider_type,
            external_cloud_provider_id=external_cloud_provider_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class GenerateReservationDetailsReportOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.costmanagement.CostManagementClient`'s
        :attr:`generate_reservation_details_report` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def _by_billing_account_id_initial(
        self, billing_account_id: str, *, start_date: str, end_date: str, **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_generate_reservation_details_report_by_billing_account_id_request(
            billing_account_id=billing_account_id,
            start_date=start_date,
            end_date=end_date,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    @distributed_trace
    def begin_by_billing_account_id(
        self, billing_account_id: str, *, start_date: str, end_date: str, **kwargs: Any
    ) -> LROPoller[JSON]:
        """Generates the reservations details report for provided date range asynchronously based on
        enrollment id. The Reservation usage details can be viewed only by certain enterprise roles.
        For more details on the roles see,
        https://docs.microsoft.com/en-us/azure/cost-management-billing/manage/understand-ea-roles#usage-and-costs-access-by-role.

        :param billing_account_id: Enrollment ID (Legacy BillingAccount ID). Required.
        :type billing_account_id: str
        :keyword start_date: Start Date. Required.
        :paramtype start_date: str
        :keyword end_date: End Date. Required.
        :paramtype end_date: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "properties": {
                        "reportUrl": "str",  # Optional. The CSV file from the reportUrl blob
                          link consists of reservation usage data with the following schema at daily
                          granularity. Known values are: "InstanceFlexibilityGroup",
                          "InstanceFlexibilityRatio", "InstanceId", "Kind", "ReservationId",
                          "ReservationOrderId", "ReservedHours", "SkuName", "TotalReservedQuantity",
                          "UsageDate", and "UsedHours".
                        "validUntil": "2020-02-20 00:00:00"  # Optional. The time at which
                          report URL becomes invalid.
                    },
                    "status": "str"  # Optional. The status of the long running operation. Known
                      values are: "Running", "Completed", and "Failed".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._by_billing_account_id_initial(  # type: ignore
                billing_account_id=billing_account_id,
                start_date=start_date,
                end_date=end_date,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: PollingMethod
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)

    def _by_billing_profile_id_initial(
        self, billing_account_id: str, billing_profile_id: str, *, start_date: str, end_date: str, **kwargs: Any
    ) -> Optional[JSON]:
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_generate_reservation_details_report_by_billing_profile_id_request(
            billing_account_id=billing_account_id,
            billing_profile_id=billing_profile_id,
            start_date=start_date,
            end_date=end_date,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    @distributed_trace
    def begin_by_billing_profile_id(
        self, billing_account_id: str, billing_profile_id: str, *, start_date: str, end_date: str, **kwargs: Any
    ) -> LROPoller[JSON]:
        """Generates the reservations details report for provided date range asynchronously by billing
        profile. The Reservation usage details can be viewed by only certain enterprise roles by
        default. For more details on the roles see,
        https://docs.microsoft.com/en-us/azure/cost-management-billing/reservations/reservation-utilization#view-utilization-in-the-azure-portal-with-azure-rbac-access.

        :param billing_account_id: BillingAccount ID. Required.
        :type billing_account_id: str
        :param billing_profile_id: BillingProfile ID. Required.
        :type billing_profile_id: str
        :keyword start_date: Start Date. Required.
        :paramtype start_date: str
        :keyword end_date: End Date. Required.
        :paramtype end_date: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
         operation to not poll, or pass in your own initialized polling object for a personal polling
         strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "properties": {
                        "reportUrl": "str",  # Optional. The CSV file from the reportUrl blob
                          link consists of reservation usage data with the following schema at daily
                          granularity. Known values are: "InstanceFlexibilityGroup",
                          "InstanceFlexibilityRatio", "InstanceId", "Kind", "ReservationId",
                          "ReservationOrderId", "ReservedHours", "SkuName", "TotalReservedQuantity",
                          "UsageDate", and "UsedHours".
                        "validUntil": "2020-02-20 00:00:00"  # Optional. The time at which
                          report URL becomes invalid.
                    },
                    "status": "str"  # Optional. The status of the long running operation. Known
                      values are: "Running", "Completed", and "Failed".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._by_billing_profile_id_initial(  # type: ignore
                billing_account_id=billing_account_id,
                billing_profile_id=billing_profile_id,
                start_date=start_date,
                end_date=end_date,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: PollingMethod
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)


class Operations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.costmanagement.CostManagementClient`'s
        :attr:`operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> Iterable[JSON]:
        """Lists all of the available cost management REST API operations.

        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "display": {
                        "description": "str",  # Optional. Operation description.
                        "operation": "str",  # Optional. Operation type: Read, write, delete,
                          etc.
                        "provider": "str",  # Optional. Service provider:
                          Microsoft.CostManagement.
                        "resource": "str"  # Optional. Resource on which the operation is
                          performed: Dimensions, Query.
                    },
                    "id": "str",  # Optional. Operation id: {provider}/{resource}/{operation}.
                    "name": "str"  # Optional. Operation name: {provider}/{resource}/{operation}.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_operations_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)
